<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[ASP.NET Core中动态为控制器类型添加特性]]></title>
      <url>/dynamically-add-features-to-the-controller-type-in-dot-net-core.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我在上一篇文章<a href="https://yangshunjie.com/add-the-webapi-service-to-the-specified-class-in-asp-net-core.html">《ASP.NET Core中为指定类添加WebApi服务功能》</a>中介绍了如何为指定类型增加WebApi服务功能，达到了一定的解耦效果（不再需要继承Controller类，不再需要Controller后缀名），但是，<code>Route</code>、<code>HttpGet</code>之类的特性类型还是需要用Mvc的，那么今天这篇文章，就介绍如何把这些标签的依赖也消灭掉。</p>
<p>如果还没看上一篇文章又不了解如何指定类型为控制器的朋友，最好先看一下上一篇文章，因为要实现本文介绍的功能，是需要先实现上一篇文章所介绍的功能的。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在没有MVC引用的类库中自定义<code>RouteAttribute</code>、<code>HttpGetAttribute</code>、<code>HttpPostAttribute</code>等等跟MVC配对的特性标签类型；其次，在定义服务接口时把这些特性标记到方法声明上面；最后在ASP.NET Core 服务启动时自动按照指定的接口上的特性给相应的接口添加MVC的标签，使得动态指定的类型也能获得MVC的路由和请求方法限制的功能。</p>
<p>用到的技术点主要是<strong>反射</strong>和利用MVC框架给出的<strong>配置点</strong>。</p>
<p>MVC框架给出的配置点在<a href="https://github.com/aspnet/Mvc/blob/de1b763d963f8be612d93889e08e43f67c98d0d5/src/Microsoft.AspNetCore.Mvc.Core/ApplicationModels/IControllerModelConvention.cs" target="_blank" rel="external"><code>IControllerModelConvention</code></a>、<a href="https://github.com/aspnet/Mvc/blob/b6a6b50776bb1ee49c0bca1353375e964101bb8a/src/Microsoft.AspNetCore.Mvc.Core/ApplicationModels/IActionModelConvention.cs" target="_blank" rel="external"><code>IActionModelConvention</code></a>、<a href="https://github.com/aspnet/Mvc/blob/16c267d95eafbf310f17bc938d00048a541be0d0/src/Microsoft.AspNetCore.Mvc.Core/ApplicationModels/IParameterModelConvention.cs" target="_blank" rel="external"><code>IParameterModelConvention</code></a>三个接口。顾名思义，它们分别对应控制器、操作、参数的类型配置，在它们的<code>Apply</code>方法中，传入了一个MVC启动阶段扫描到的类型，开发者可以通过给这个类型添加各种MVC特性，如<code>RouteData</code>、<code>Attributes</code>、<code>Filters</code>等。但是，这些特性组合是有规则的，不能一股脑儿地都添加进去，MVC的机制中会用<code>SelectorModel</code>来将特性进行分组。</p>
<p>例如有以下的操作方法和它的特性：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token punctuation">[</span>HttpGet<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token function">AcceptVerbs</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"PUT"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token function">HttpPost</span><span class="token punctuation">(</span><span class="token string">"Api/Things"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DoThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么MVC中就需要把他们分为两组：</p>
<ol>
<li><code>[HttpPost(&quot;Api/Things&quot;)]</code></li>
<li><code>[HttpGet], [AcceptVerbs(&quot;POST&quot;, &quot;PUT&quot;)]</code></li>
</ol>
<p>所以，这个分组的规则，我们怎么去处理呢？其实，在MVC的源码中就有这样的方法<a href="https://github.com/aspnet/Mvc/blob/de389226011fb15140ee0a8d6a2429b2eb943f3a/src/Microsoft.AspNetCore.Mvc.Core/Internal/DefaultApplicationModelProvider.cs#L439" target="_blank" rel="external"><code>IList&lt;SelectorModel&gt; CreateSelectors(IList&lt;object&gt; attributes)</code></a>，我们把它复制过来就好了。</p>
<h3 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h3><p>回到我们的需求，我们需要把指定类型的方法都加上MVC特性，就需要自定义一些<code>ModelConvention</code>。由于我们的需求比较简单，只需特性作用按类型来使指定类型获得MVC特性，我们只需在构造方法中传入指定类型，分别为控制器、操作和参数这三个作用类型都定义一个。由于篇幅问题，下面只贴Action的实现来讲解，另外两个大家可以看我<a href="https://github.com/ElderJames/shriek-fx/tree/master/src/Shriek.ServiceProxy.Http.Server/Internal" target="_blank" rel="external">项目中的源码</a>。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> HttpGet <span class="token operator">=</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">.</span>HttpGetAttribute<span class="token punctuation">;</span>
<span class="token keyword">using</span> HttpPost <span class="token operator">=</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">.</span>HttpPostAttribute<span class="token punctuation">;</span>
<span class="token keyword">using</span> Route <span class="token operator">=</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">.</span>RouteAttribute<span class="token punctuation">;</span>

<span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">ActionModelConvention</span> <span class="token punctuation">:</span> IActionModelConvention
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//构造方法传入指定接口类型</span>
    <span class="token keyword">public</span> <span class="token function">ActionModelConvention</span><span class="token punctuation">(</span>Type serviceType<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>serviceType <span class="token operator">=</span> serviceType<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> Type serviceType <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Apply</span><span class="token punctuation">(</span>ActionModel action<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//判断是否为指定接口类型的实现类</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>serviceType<span class="token punctuation">.</span><span class="token function">IsAssignableFrom</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>Controller<span class="token punctuation">.</span>ControllerType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token keyword">var</span> actionParams <span class="token operator">=</span> action<span class="token punctuation">.</span>ActionMethod<span class="token punctuation">.</span><span class="token function">GetParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//这串linq是查询出接口类型中与当前action相对应的方法，从中获取特性</span>
        <span class="token keyword">var</span> method <span class="token operator">=</span> serviceType<span class="token punctuation">.</span><span class="token function">GetMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span>mth <span class="token operator">=</span><span class="token operator">></span>
        <span class="token punctuation">{</span>
            <span class="token keyword">var</span> mthParams <span class="token operator">=</span> mth<span class="token punctuation">.</span><span class="token function">GetParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> action<span class="token punctuation">.</span>ActionMethod<span class="token punctuation">.</span>Name <span class="token operator">==</span> mth<span class="token punctuation">.</span>Name
                   <span class="token operator">&amp;&amp;</span> actionParams<span class="token punctuation">.</span>Length <span class="token operator">==</span> mthParams<span class="token punctuation">.</span>Length
                   <span class="token operator">&amp;&amp;</span> actionParams<span class="token punctuation">.</span><span class="token function">Any</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> mthParams<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">></span> x<span class="token punctuation">.</span>Name <span class="token operator">==</span> o<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Any</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">></span> x<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">var</span> attrs <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">GetCustomAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> actionAttrs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">var</span> att <span class="token keyword">in</span> attrs<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//下面的HttpMethodAttribute是我们自己写的特性类型</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>att <span class="token keyword">is</span> HttpMethodAttribute methodAttr<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token keyword">var</span> httpMethod <span class="token operator">=</span> methodAttr<span class="token punctuation">.</span>Method<span class="token punctuation">;</span>
                    <span class="token keyword">var</span> path <span class="token operator">=</span> methodAttr<span class="token punctuation">.</span>Path<span class="token punctuation">;</span>

                    <span class="token keyword">if</span> <span class="token punctuation">(</span>httpMethod <span class="token operator">==</span> HttpMethod<span class="token punctuation">.</span>Get<span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        <span class="token comment" spellcheck="true">//添加的HttpGet和HttpPost使用了命名空间别名</span>
                        actionAttrs<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>HttpGet<span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>httpMethod <span class="token operator">==</span> HttpMethod<span class="token punctuation">.</span>Post<span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        actionAttrs<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>HttpPost<span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                 <span class="token comment" spellcheck="true">//下面的RouteAttribute是我们自己写的特性类型</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>att <span class="token keyword">is</span> RouteAttribute routeAttr<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    actionAttrs<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Route<span class="token punctuation">)</span><span class="token punctuation">,</span> routeAttr<span class="token punctuation">.</span>Template<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>actionAttrs<span class="token punctuation">.</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            action<span class="token punctuation">.</span>Selectors<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//AddRange静态方法就是从源码中复制过来的</span>
            ModelConventionHelper<span class="token punctuation">.</span><span class="token function">AddRange</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>Selectors<span class="token punctuation">,</span> ModelConventionHelper<span class="token punctuation">.</span><span class="token function">CreateSelectors</span><span class="token punctuation">(</span>actionAttrs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码其实还省略了其它的请求方式，我的源码中是有的，大家也可以前去查看。除了<a href="https://github.com/ElderJames/shriek-fx/blob/master/src/Shriek.ServiceProxy.Http.Server/Internal/ActionModelConvention.cs" target="_blank" rel="external"><code>ActionModelConvention</code></a>，还需要写<a href="https://github.com/ElderJames/shriek-fx/blob/master/src/Shriek.ServiceProxy.Http.Server/Internal/ControllerModelConvention.cs" target="_blank" rel="external"><code>ControllerModelConvention</code></a>和<a href="https://github.com/ElderJames/shriek-fx/blob/master/src/Shriek.ServiceProxy.Http.Server/Internal/ParameterModelConvention.cs" target="_blank" rel="external"><code>ParameterModelConvention</code></a>。</p>
<h3 id="配置到MVC框架"><a href="#配置到MVC框架" class="headerlink" title="配置到MVC框架"></a>配置到MVC框架</h3><p>核心的代码写好了，那么怎么让它起作用呢？其实官方的源码已经提供了示例：<a href="https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/test/WebSites/ApplicationModelWebSite/Startup.cs#L16" target="_blank" rel="external">Mvc/test/WebSites/ApplicationModelWebSite/Startup.cs</a>，我们只需在<code>services.AddMvc()</code>里的<code>setupAction</code>委托中将我们的配置类型添加到<a href="https://github.com/aspnet/Mvc/blob/b4fe715c71f472180069f674bde3ef8014064d64/src/Microsoft.AspNetCore.Mvc.Core/MvcOptions.cs#L59" target="_blank" rel="external">MvcOptions.Conventions</a>属性里就好了，这个属性是用来添加所有模型配置的，然后MVC启动后会把这些配置都扫描处理一遍。</p>
<p>来看看我这里的实现：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//假设我们定义了这样的接口</span>
<span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ITestService</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"{name}"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> HttpGet<span class="token punctuation">]</span>
    <span class="token keyword">string</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//AddMvc也一样，这里用AddMvcCore只是为了减少依赖</span>
services<span class="token punctuation">.</span><span class="token function">AddMvcCore</span><span class="token punctuation">(</span>opt<span class="token operator">=</span><span class="token operator">></span>
    <span class="token punctuation">{</span>
        opt<span class="token punctuation">.</span>Conventions<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ControllerModelConvention</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        opt<span class="token punctuation">.</span>Conventions<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionModelConvention</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        opt<span class="token punctuation">.</span>Conventions<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ParameterModelConvention</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然了，我这里是因为指定类型是通过反射获取的，所以用了Type类型作为参数，大家也可以用泛型，在构造方法里获取对象类型。</p>
<h3 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h3><p>接下来，除了这三个<code>ModelConvention</code>类型，我把整个实现代码贴一下，让大家看得比较直观，最后会跟上一篇文章的实现加入进来。因为，如果没有昨天的工作，我们指定的类型不被MVC识别为控制器的话，我们是无法实现为这些类型添加MVC属性的。</p>
<p>首先，先创建一个控制台程序，引入一下Nuget包</p>
<pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PackageReference</span> <span class="token attr-name">Include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Microsoft.AspNetCore.Hosting<span class="token punctuation">"</span></span> <span class="token attr-name">Version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.0.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PackageReference</span> <span class="token attr-name">Include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Microsoft.AspNetCore.Mvc.Core<span class="token punctuation">"</span></span> <span class="token attr-name">Version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.0.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接着，定义一个接口以及它的实现，接口中标记了一些自定义特性，而实现类中完全没有：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ITestService</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"{name}"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> HttpGet<span class="token punctuation">]</span>
    <span class="token keyword">string</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestService</span> <span class="token punctuation">:</span> ITestService
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">string</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Hello "</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在控制台程序的入口文件Program.cs的Main方法中写入一下代码：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">new</span> <span class="token class-name">WebHostBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">UseKestrel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">UseUrls</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">ConfigureServices</span><span class="token punctuation">(</span>services <span class="token operator">=</span><span class="token operator">></span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//使用AddMvc亦可</span>
                services<span class="token punctuation">.</span><span class="token function">AddMvcCore</span><span class="token punctuation">(</span>opt<span class="token operator">=</span><span class="token operator">></span>
                <span class="token punctuation">{</span>
                    opt<span class="token punctuation">.</span>Conventions<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ControllerModelConvention</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    opt<span class="token punctuation">.</span>Conventions<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionModelConvention</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    opt<span class="token punctuation">.</span>Conventions<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ParameterModelConvention</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true">//下面这段是上一篇文章里的内容</span>
                <span class="token punctuation">.</span><span class="token function">ConfigureApplicationPartManager</span><span class="token punctuation">(</span>manager <span class="token operator">=</span><span class="token operator">></span>
                <span class="token punctuation">{</span>
                    <span class="token keyword">var</span> featureProvider <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceControllerFeatureProvider</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    manager<span class="token punctuation">.</span>FeatureProviders<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>featureProvider<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Configure</span><span class="token punctuation">(</span>app <span class="token operator">=</span><span class="token operator">></span> app<span class="token punctuation">.</span><span class="token function">UseMvc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一切编译通过后，点击运行，在浏览器中访问”<a href="http://localhost:8080/test/elderjames" target="_blank" rel="external">http://localhost:8080/test/elderjames</a>”，如果看到返回了“Hello elderjames”，那么就大功告成啦！</p>
<p><img src="/images/add_webapi_to_class/1.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章中主要介绍了通过实现<a href="https://github.com/aspnet/Mvc/blob/de1b763d963f8be612d93889e08e43f67c98d0d5/src/Microsoft.AspNetCore.Mvc.Core/ApplicationModels/IControllerModelConvention.cs" target="_blank" rel="external"><code>IControllerModelConvention</code></a>、<a href="https://github.com/aspnet/Mvc/blob/b6a6b50776bb1ee49c0bca1353375e964101bb8a/src/Microsoft.AspNetCore.Mvc.Core/ApplicationModels/IActionModelConvention.cs" target="_blank" rel="external"><code>IActionModelConvention</code></a>、<a href="https://github.com/aspnet/Mvc/blob/16c267d95eafbf310f17bc938d00048a541be0d0/src/Microsoft.AspNetCore.Mvc.Core/ApplicationModels/IParameterModelConvention.cs" target="_blank" rel="external"><code>IParameterModelConvention</code></a>三个接口实现为指定为控制器的类型添加MVC特性的方法。</p>
<p>本篇文章发现源码的部分受到<a href="https://github.com/maxzhang1985" target="_blank" rel="external"><em>max zhang</em></a> 和他的群里的群友<em>福州 | Today</em>的帮助，在此表示衷心的感谢。</p>
<p>在接下来的文章中，会介绍使用功能强大的.NTE Core开源AOP框架<a href="https://github.com/dotnetcore/AspectCore-Framework" target="_blank" rel="external"><strong>AspectCore</strong></a>实现的动态代理客户端，注册以上所说的接口，即可获得可以调用对应的WebApi服务的功能。这些工作的源码可以在<a href="https://github.com/ElderJames/shriek-fx/tree/master/samples/Shriek.Samples.WebApiProxy" target="_blank" rel="external">我的框架示例项目</a>中运行，大家有兴趣可以看看效果。</p>
<p><strong>感谢阅读和批评指教！</strong></p>
<p>[温馨提示：为方便大家看文中提到的源码，原文中有大量指向源码链接，如果您看的是没有链接的转载，可以再来看我的原文。]</p>
]]></content>
      
        <categories>
            
            <category> .NET Core </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> WebApi </tag>
            
            <tag> MVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.NET Core中为指定类添加WebApi服务功能]]></title>
      <url>/add-the-webapi-service-to-the-specified-class-in-asp-net-core.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>POCO Controller是 <strong>ASP.NET Core</strong> 中的一个特性，虽然在2015年刚发布的时候就有这个特性了，可是大多数开发者都只是按原有的方式去写，而没有用到这个特性。其实，如果利用这个特性进行稍微封装后，用在SOA架构中Service层的场景中是极其便利的。这篇文章主要就是说我最近在学习使用开源AOP库AspectCore写WebApi动态代理客户端的时候，实现为普通类无添加WebApi服务的过程。</p>
<h3 id="POCO控制器简介"><a href="#POCO控制器简介" class="headerlink" title="POCO控制器简介"></a>POCO控制器简介</h3><p>POCO控制器就是ASP.NET Core项目中所有带有<code>Controller</code>后缀的类、或者标记了<code>[Controller]</code>特性的类，虽然没有像模版项目中那样继承自<strong>Controller类</strong>，也会被识别为控制器，拥有跟普通控制器一样的功能，像下面这段代码中，两个类都会被识别成控制器：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PocoController</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> IActionResult <span class="token function">Index</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ContentResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Content <span class="token operator">=</span> “Hello <span class="token keyword">from</span> POCO controller<span class="token operator">!</span>” <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span>Controller<span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Poco</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> IActionResult <span class="token function">Index</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ContentResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Content <span class="token operator">=</span> “Hello <span class="token keyword">from</span> POCO controller<span class="token operator">!</span>” <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="POCO控制器原理"><a href="#POCO控制器原理" class="headerlink" title="POCO控制器原理"></a>POCO控制器原理</h3><p>其实，在ASP.NET Core中，已经不像旧版本的 ASP.NET WebApi 那样，通过ControllerFactory来创建Controller，多亏于ASP.NET Core一脉相承的IoC框架 <code>Microsoft.Extensions.DependencyInjection</code>，ASP.NET Core中的内部实现变得更优雅。其中POCO控制器的核心原理就在<a href="https://github.com/aspnet/Mvc/blob/2bacb6003f3bc2c3b58107c1118346dca3f5fa13/src/Microsoft.AspNetCore.Mvc.Core/ApplicationParts/IApplicationFeatureProviderOfT.cs" target="_blank" rel="external"><code>IApplicationFeatureProvider&lt;ControllerFeature&gt;</code></a>这个接口的实现<a href="https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Controllers/ControllerFeatureProvider.cs#L15" target="_blank" rel="external"><code>ControllerFeatureProvider</code></a>。</p>
<p>通过<a href="https://github.com/aspnet/Mvc/search?p=1&amp;q=IApplicationFeatureProvider&amp;type=&amp;utf8=%E2%9C%93" target="_blank" rel="external">aspnet/Mvc项目的Github源码仓库</a>中查询得知，Mvc里把Controller、ViewComponent、TagHelper、Views等组件定义为特性(Feature)，如<code>ControllerFeature</code>，特性里就存放了应用中被识别为相组件的类型的集合，如如<code>ControllerFeature</code>中就存放了所有<code>Controller</code>类型。<code>IApplicationFeatureProvider&lt;ControllerFeature&gt;</code>这个接口是用来给MVC框架提供控制器类型识别的接口，当把这个接口的实现注册到服务配置中，就能为其中识别的类型提供控制器功能。</p>
<p><a href="https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Controllers/ControllerFeatureProvider.cs#L15" target="_blank" rel="external">ControllerFeatureProvider</a>是这个接口的默认实现，其中有一个方法<code>IsController(TypeInfo typeInfo)</code>的功能就是判断某类型是否为控制器的。而接口方法<code>PopulateFeature(IEnumerable&lt;ApplicationPart&gt; parts,ControllerFeature feature)</code>则为把传入的 “Mvc应用部分（<code>ApplicationPart</code>，大概是指Mvc的作用程序集）”中的类型都一一判断，如果是控制器，那么就加入控制器特性对象中。</p>
<h3 id="实现自定义判断规则"><a href="#实现自定义判断规则" class="headerlink" title="实现自定义判断规则"></a>实现自定义判断规则</h3><p>通过上面的剖析，我们就知道要实现自定义的控制器判断规则，只需要重写<code>ControllerFeature</code>类或者重新实现<code>IApplicationFeatureProvider&lt;ControllerFeature&gt;</code>接口，但是由于<code>PopulateFeature</code>不是虚方法或抽象方法，所以不能被重写，那么只能重新写一个类来实现<code>IApplicationFeatureProvider&lt;ControllerFeature&gt;</code>接口了。为了兼容原来规则，我把原来的规则照搬过来，复制了<code>IsController</code>的方法（开源的好处），并且在<code>PopulateFeature</code>中加入了自己的规则。先贴代码，避免篇幅过长，<code>IsController</code>方法的实现就直接链接到<a href="https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Controllers/ControllerFeatureProvider.cs#L41" target="_blank" rel="external">源码</a>了：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">ServiceControllerFeatureProvider</span> <span class="token punctuation">:</span> IApplicationFeatureProvider<span class="token operator">&lt;</span>ControllerFeature<span class="token operator">></span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token keyword">string</span> ControllerTypeNameSuffix <span class="token operator">=</span> <span class="token string">"Controller"</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> IEnumerable<span class="token operator">&lt;</span>Type<span class="token operator">></span> ServiceTypes<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">ServiceControllerFeatureProvider</span><span class="token punctuation">(</span>IEnumerable<span class="token operator">&lt;</span>Type<span class="token operator">></span> ServiceTypes<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>ServiceTypes <span class="token operator">=</span> ServiceTypes<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PopulateFeature</span><span class="token punctuation">(</span>IEnumerable<span class="token operator">&lt;</span>ApplicationPart<span class="token operator">></span> parts<span class="token punctuation">,</span> ControllerFeature feature<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">var</span> type <span class="token keyword">in</span> Reflection<span class="token punctuation">.</span>CurrentAssembiles<span class="token punctuation">.</span><span class="token function">SelectMany</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">></span> o<span class="token punctuation">.</span>DefinedTypes<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsController</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">||</span> ServiceTypes<span class="token punctuation">.</span><span class="token function">Any</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">></span> type<span class="token punctuation">.</span>IsClass <span class="token operator">&amp;&amp;</span> o<span class="token punctuation">.</span><span class="token function">IsAssignableFrom</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>feature<span class="token punctuation">.</span>Controllers<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                    feature<span class="token punctuation">.</span>Controllers<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">bool</span> <span class="token function">IsController</span><span class="token punctuation">(</span>TypeInfo typeInfo<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码的原理，是按照我的框架的需求来改写的，构造方法传入的参数ServiceTypes是定义了服务方法的接口的类型，接口和对应实现类似于以下代码，这些代码可以写在一个.NET Core控制台项目中。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ITestService</span>
<span class="token punctuation">{</span>
    <span class="token keyword">string</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestService</span> <span class="token punctuation">:</span> ITestService
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"{name}"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> HttpGet<span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">string</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Hello "</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中TestService类就是会被识别为控制器的类，但是接口和实现是可以分开在不同程序集的。通过原本<code>ControllerFeatureProvider</code>类中<code>PopulateFeature</code>方法的<code>parts</code>参数中的类型是不包括除了引用了Mvc的程序集的其它程序集的，所以我这里用自己实现的类型扫描类<code>Reflection</code>中的<code>CurrentAssembiles</code>静态变量来获取当前应用程序的所有引用的（自己创建的项目）程序集的，具体实现的代码在我的框架[Shriek]的<a href="https://github.com/ElderJames/shriek-fx/blob/master/src/Shriek/Utils/Reflection.cs" target="_blank" rel="external">源码中</a>。</p>
<h3 id="配置自定义规则"><a href="#配置自定义规则" class="headerlink" title="配置自定义规则"></a>配置自定义规则</h3><p>现在，我们拥有了自定义控制器识别规则<code>ServiceControllerFeatureProvider</code>，那么，怎么配置到Mvc中呢？又要去翻源码了！在<code>MvcCoreMvcBuilderExtensions.cs</code>扩展类中，有一个<code>IMvcBuilder</code>的扩展方法<a href="https://github.com/aspnet/Mvc/blob/1c4b0fcdf38320b2f02c0bb7c31df5bd391ace07/src/Microsoft.AspNetCore.Mvc.Core/DependencyInjection/MvcCoreMvcBuilderExtensions.cs#L93" target="_blank" rel="external"><code>ConfigureApplicationPartManager</code></a>（<code>IMvcCoreBuilder</code>也有这样的<a href="https://github.com/aspnet/Mvc/blob/1c4b0fcdf38320b2f02c0bb7c31df5bd391ace07/src/Microsoft.AspNetCore.Mvc.Core/DependencyInjection/MvcCoreMvcCoreBuilderExtensions.cs#L152" target="_blank" rel="external">扩展方法</a>），它的参数是传入<code>ApplicationPartManager</code>参数的委托，而<a href="https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/ApplicationParts/ApplicationPartManager.cs#L13" target="_blank" rel="external"><code>ApplicationPartManager</code></a>中有一个<code>FeatureProviders</code>属性，用来存储所有<code>IApplicationFeatureProvider</code>实例，会在应用第一次运行的时候，循环这些“特性提供器”提供所有上面提到的MVC特性。所以，只要我们在这里添加我们自定义的控制器特性提供器，MVC框架内部就能识别我们的指定的类型为控制器，并为他们添加控制器的相关功能。</p>
<p>设计有点绕，那么我们用代码来实现：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//示例直接new ServiceCollection对象，下面有完整的能运行的示例代码。</span>
<span class="token keyword">var</span> services <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

services<span class="token punctuation">.</span><span class="token function">AddMvcCore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">ConfigureApplicationPartManager</span><span class="token punctuation">(</span>manager <span class="token operator">=</span><span class="token operator">></span>
        <span class="token punctuation">{</span>
            <span class="token keyword">var</span> featureProvider <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceControllerFeatureProvider</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            manager<span class="token punctuation">.</span>FeatureProviders<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>featureProvider<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="看看效果"><a href="#看看效果" class="headerlink" title="看看效果"></a>看看效果</h3><p>现在，在TestService类所在项目文件中引入以下Nuget包（没错，运行一个webapi只需要两个Nuget包）：</p>
<pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PackageReference</span> <span class="token attr-name">Include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Microsoft.AspNetCore.Hosting<span class="token punctuation">"</span></span> <span class="token attr-name">Version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.0.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PackageReference</span> <span class="token attr-name">Include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Microsoft.AspNetCore.Mvc.Core<span class="token punctuation">"</span></span> <span class="token attr-name">Version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.0.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后在控制台程序的入口文件Program.cs的Main方法中写入一下代码：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">new</span> <span class="token class-name">WebHostBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">UseKestrel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">UseUrls</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">ConfigureServices</span><span class="token punctuation">(</span>services <span class="token operator">=</span><span class="token operator">></span>
            <span class="token punctuation">{</span>
                services<span class="token punctuation">.</span><span class="token function">AddMvcCore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">ConfigureApplicationPartManager</span><span class="token punctuation">(</span>manager <span class="token operator">=</span><span class="token operator">></span>
                <span class="token punctuation">{</span>
                    <span class="token keyword">var</span> featureProvider <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceControllerFeatureProvider</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ITestService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    manager<span class="token punctuation">.</span>FeatureProviders<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>featureProvider<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Configure</span><span class="token punctuation">(</span>app <span class="token operator">=</span><span class="token operator">></span> app<span class="token punctuation">.</span><span class="token function">UseMvc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一切编译通过后，点击运行，在浏览器中访问”<a href="http://localhost:8080/test/elderjames" target="_blank" rel="external">http://localhost:8080/test/elderjames</a>”，如果看到返回了“Hello elderjames”，那么就大功告成啦！</p>
<p><img src="/images/add_webapi_to_class/1.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章中主要介绍了通过实现<code>IApplicationFeatureProvider&lt;ControllerFeature&gt;</code>接口实现设置指定类型为WebApi控制器的方法。</p>
<p>在接下来的文章中，我会介绍如何从接口获取自定义特性标签，实现从接口获得mvc特性，使得接口和实现类都不依赖MVC库的方法，只要在接口中以标记特性的方式定义了路由和http方法，实现类的操作就都按照接口的路由和http方法去提供WebApi服务，最后还要介绍使用功能强大的.NTE Core开源AOP框架<a href="https://github.com/dotnetcore/AspectCore-Framework" target="_blank" rel="external"><strong>AspectCore</strong></a>实现的动态代理客户端，注册以上所说的接口，即可获得可以调用对应的WebApi服务的功能。这些工作的源码可以在<a href="https://github.com/ElderJames/shriek-fx/tree/master/samples/Shriek.Samples.WebApiProxy" target="_blank" rel="external">我的框架示例项目</a>中运行，大家有兴趣可以看看效果。</p>
<p><strong>感谢阅读和批评指教！</strong></p>
<p>[温馨提示：为方便大家看文中提到的源码，原文中有大量指向源码链接，如果您看的是没有链接的转载，可以再来看我的原文。]</p>
]]></content>
      
        <categories>
            
            <category> .NET Core </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> WebApi </tag>
            
            <tag> MVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[更换阿里云Docker镜像源]]></title>
      <url>/change-the-docker-image-origin-to-aliyun.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>由于Docker技术比虚拟机技术更为轻便、快捷。自 2013 年 3 月以Apache 2.0授权协议开源后，到近两年成为当下分布式系统最热门的开发运维方式。由于国内网络连接Docker官方源很慢，甚至无法从官方源拉取镜像创建容器，所以这篇文章介绍如何把Docker源更换为阿里云的，使中国开发者也能学习并运用到Docker带来的DevOps变革。</p>
<h4 id="运行环境-与换源无关-："><a href="#运行环境-与换源无关-：" class="headerlink" title="运行环境 (与换源无关)："></a>运行环境 (与换源无关)：</h4><ul>
<li>Windows 10</li>
<li>Docker for Windows <a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="external">下载</a></li>
<li>Kitematic <a href="https://github.com/docker/kitematic/releases/download/v0.17.1/Kitematic-0.17.1-Windows.zip" target="_blank" rel="external">下载</a></li>
</ul>
<p>安装Docker的同时，我们可以先登录阿里云管理平台，通过前台页面进入【容器服务控制台】(<a href="https://cs.console.aliyun.com/#/repo" target="_blank" rel="external">https://cs.console.aliyun.com/#/repo</a>)</p>
<h4 id="登录阿里云容器服务控制台"><a href="#登录阿里云容器服务控制台" class="headerlink" title="登录阿里云容器服务控制台"></a>登录阿里云容器服务控制台</h4><p>容器控制台的入口不是在一开始登录控制台的页面里的，所以如果以后记不住这个地址，可以按以下页面进入。</p>
<ol>
<li><p>指向阿里云首页的导航栏“产品”选项，从下拉的列表中点击“容器服务”</p>
<p> <img src="/images/aliyun-docker/1.png" alt=""></p>
</li>
<li><p>从容器服务页面的上宣传图中点击“管理控制台”按钮进入。</p>
<p> <img src="/images/aliyun-docker/2.png" alt=""></p>
</li>
</ol>
<h4 id="获取镜像地址"><a href="#获取镜像地址" class="headerlink" title="获取镜像地址"></a>获取镜像地址</h4><p>进入控制台后，点击副侧边栏的“镜像”选项卡，在进入的页面中点击右上方的“镜像仓库控制台”链接。</p>
<p><img src="/images/aliyun-docker/3.png" alt=""></p>
<p>再点击副侧边栏的“Docker Hub 镜像站点”选项卡，就能看到阿里云分配的“专属加速器地址”：</p>
<p><img src="/images/aliyun-docker/4.png" alt=""></p>
<h4 id="配置到Docker"><a href="#配置到Docker" class="headerlink" title="配置到Docker"></a>配置到Docker</h4><p>这个地址怎么用呢？当然是配置到Docker的设置里了。运行Docker后，右键点击Docker Logo，点击setting按钮。在进入设置面板后，点击“Daemon”选项卡，点击“Basic”左边的开关，在下边输入框中会出现空的配置json字符串，这时就把从阿里云获取到的镜像地址填入“registry-mirrors”节点，如图：</p>
<p><img src="/images/aliyun-docker/5.png" alt=""></p>
<p>然后点击Apply，大功告成！</p>
<p>我们可以通过在Kitematic中选择一个镜像创建一个容器试试看。</p>
<p><img src="/images/aliyun-docker/6.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[领域驱动设计（DDD）项目收集]]></title>
      <url>/ddd-project-collection.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从来了现在这家公司之后，就喜欢实践DDD开发程序，最近开始写一个叫做<a href="https://github.com/ElderJames/ShriekFx" target="_blank" rel="external">尖叫(Shriek)</a>的轻量DDD开源框架，下面列出一些在学习和开发过程中参考过的DDD开源项目。希望对淋浴驱动设计有兴趣的同行可以一起交流。</p>
<h1 id="NET-Core"><a href="#NET-Core" class="headerlink" title=".NET Core"></a>.NET Core</h1><ul>
<li><a href="https://github.com/Weapsy/Weapsy" target="_blank" rel="external">Weapsy</a></li>
<li><a href="https://github.com/EduardoPires/EquinoxProject" target="_blank" rel="external">EquinoxProject</a></li>
<li><a href="https://github.com/thangchung/magazine-website" target="_blank" rel="external">magazine-website</a></li>
<li><a href="https://github.com/daxnet/Apworks" target="_blank" rel="external">Apworks</a></li>
<li><a href="https://github.com/daxnet/we-text" target="_blank" rel="external">we-text</a></li>
<li><a href="https://github.com/mastreeno/Merp" target="_blank" rel="external">Merp</a></li>
<li><a href="https://github.com/Kation/ComBoost" target="_blank" rel="external">ComBoost</a></li>
</ul>
<h1 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h1><ul>
<li><a href="https://github.com/tangxuehua/enode" target="_blank" rel="external">ENode</a></li>
<li><a href="https://github.com/ElderJames/MyDiary.CQRS" target="_blank" rel="external">MyDiary.CQRS</a></li>
<li><a href="https://github.com/ElderJames/naa4e" target="_blank" rel="external">Microsoft .NET企业级应用架构设计（第2版）源码</a></li>
</ul>
<p>最近身体不适，对这些项目的介绍我会在身体好了之后补上。</p>
]]></content>
      
        <categories>
            
            <category> DDD </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET Core </tag>
            
            <tag> .NET </tag>
            
            <tag> DDD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[给你的域名加把锁：免费Https申请]]></title>
      <url>/how-to-request-a-free-https.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>关于Https的介绍，先引用一段维基百科的描述：</p>
<blockquote>
<p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。<br>历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。</p>
</blockquote>
<p>除了平常我们看不见的安全性外，拥有Https前缀的域名被浏览器加了把锁，看起来就比没有的牛~而且，苹果在去年已经规定所有应用内链接都需要有https了！</p>
<p>企业级ssl证书费用高昂，如果只是个人网站没必要用企业级的，使用一些免费的就好了。接下来，我就以我的个人域名为例，介绍下申请免费https的流程。</p>
<p>此处炫耀一下：  <img src="/images/15.png" alt=""></p>
<h4 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h4><ol>
<li>一个自己的域名，可以在国内的域名注册商购买注册，如阿里云、腾讯云，然后最好是做好备案，因为微信等一些客户端的链接分享都要求备案过的域名才能正常访问。当然，不备案也不妨碍绑定Github Pages和国外服务器。</li>
</ol>
<h4 id="教程目标"><a href="#教程目标" class="headerlink" title="教程目标"></a>教程目标</h4><ol>
<li>给自己的域名设置 Flexible SSL 认证，即网站到解析服务器间的加密传输，让域名可以使用https</li>
<li>访问http域名，自动301跳转到https</li>
<li>访问<a href="http://www.yourdomain.com" target="_blank" rel="external">http://www.yourdomain.com</a> ,会自动跳转到<a href="https://yourdomain.com（当然，可以反过来）" target="_blank" rel="external">https://yourdomain.com（当然，可以反过来）</a></li>
</ol>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="注册CloudFlare帐户，并添加域名解析"><a href="#注册CloudFlare帐户，并添加域名解析" class="headerlink" title="注册CloudFlare帐户，并添加域名解析"></a>注册CloudFlare帐户，并添加域名解析</h5><p>访问<a href="https://www.cloudflare.com/a/sign-up" target="_blank" rel="external">CloudFlare注册页面</a>,简单地输入邮箱和密码就能注册成功好。</p>
<h5 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h5><p>登录后，访问<a href="https://www.cloudflare.com/a/add-site" target="_blank" rel="external">Add Websites页面</a>添加一个域名，如我的是yangshunjie.com，然后点击【Begin Scan】扫描。大概需要等待1分钟，完成后点击【Continue Setup】继续下一步。</p>
<p><img src="/images/6.png" alt=""></p>
<h5 id="设置解析项"><a href="#设置解析项" class="headerlink" title="设置解析项"></a>设置解析项</h5><p>这时，我们需要添加域名解析了，将域名解析到指向的服务器。这跟普通的域名解析绑定是一样的。如果要绑定Github Pages，就需要参考<a href="https://help.github.com/articles/setting-up-an-apex-domain/#configuring-a-records-with-your-dns-provider" target="_blank" rel="external">Github Help官方指南</a>添加A记录分别指向<code>192.30.252.153</code>和<code>192.30.252.154</code>。另外再设置一个www的CNAME记录，指向yangshunjie.com。</p>
<p><img src="/images/7.png" alt=""></p>
<h5 id="修改域名解析服务器"><a href="#修改域名解析服务器" class="headerlink" title="修改域名解析服务器"></a>修改域名解析服务器</h5><p>登录你的域名注册商的控制后台，把DNS解析服务器改为CloudFlare提供的两个地址。然后等待转移完成。我的域名是在阿里云注册的，所以这里截图演示一下：</p>
<p><img src="/images/8.png" alt=""><br><img src="/images/9.png" alt=""></p>
<blockquote>
<p>注：官方说明，域名服务器修改最长需要72小时生效 ，用了两个域名测试，大约需要 5~30 分钟，看到 Status: Active 即可。</p>
</blockquote>
<p><img src="/images/10.png" alt=""></p>
<h5 id="设置加密方式"><a href="#设置加密方式" class="headerlink" title="设置加密方式"></a>设置加密方式</h5><p>回到CloudFlare，点击上部的 crypto 菜单 , 然后设置 <strong><em>Flexible SSL</em></strong> 。</p>
<p><img src="/images/11.png" alt=""></p>
<h5 id="设置页面规则"><a href="#设置页面规则" class="headerlink" title="设置页面规则"></a>设置页面规则</h5><p> 接着点击 Page Rules 菜单，添加两个规则，一个是将<code>http://yangshunjie.com/*</code>设为 Always Use HTTPS,一个是讲<code>http://www.yangshunjie.com/</code>重定向到<code>https://yangshunjie.com/</code>(如果需要默认跳转到www开头的域名，则这里就重定向到<code>https://www.yangshunjie.com/</code>即可)。</p>
<p><img src="/images/12.png" alt=""><br><img src="/images/13.png" alt=""><br><img src="/images/14.png" alt=""></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>以后你需要绑定其它服务器，都需要在这里配置。DNS记录视缓存的时间一般需要5~30分钟生效。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Github Pages </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github Pages </tag>
            
            <tag> Https </tag>
            
            <tag> SSL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用AppVeyor持续集成你的Hexo博客]]></title>
      <url>/Use-Appveyor-to-continuously-integrate-your-Hexo-blog.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>炎热的盛夏，真的是让人难以入眠。在这种不免之夜，如果还加上停电……简直就是惨绝人寰了！</p>
<p>还好，今晚没停电，可以让我吹着风扇安心去写这篇文章。</p>
<p>距离我建立这个博客都过去一周了，一直都在做这个站点的建设。首先是找到个好看的主题，之后绑定自己的https域名，然后是寻找更多玩法，比如放了只可爱的猫咪在右下角，它会跟随者你的鼠标摇头摆尾~比如在底部贴了我的GitHub贡献马赛克，在我的朋友页面抓取我的Github followers，还有就是这篇文章的重点，用AppVeyor去持续集成Hexo博客。</p>
<p>AppVeyor是目前唯一支持.NET开源项目的持续集成功能，运行环境是Windows，身为.NET开发者和软粉的我，怎么不支持一下这个有情怀的服务商呢？</p>
<p><del>太晚了，挖坑，明天继续写。</del> </p>
<h4 id="第一步，创建CI项目"><a href="#第一步，创建CI项目" class="headerlink" title="第一步，创建CI项目"></a>第一步，创建CI项目</h4><p>访问<a href="https://ci.appveyor.com/projects" target="_blank" rel="external">AppVeyor网站</a>，注册或使用Github帐号授权登录，在PROJECTS页面点击【NEW PROJECT】，然后在右侧选择你的Hexo博客所在的仓库。</p>
<p><img src="/images/1.png" alt=""></p>
<h4 id="第二步，配置项目和环境变量"><a href="#第二步，配置项目和环境变量" class="headerlink" title="第二步，配置项目和环境变量"></a>第二步，配置项目和环境变量</h4><p>点击项目里的[SETTING]选项卡，配置以下几项：</p>
<ol>
<li>Default branch -&gt; [你存放原文件的分支名]</li>
<li>Branches to build -&gt; 选择Only branches specified below,并填入[你存放原文件的分支名]</li>
</ol>
<p>如下图，然后点击一下下方的Save按钮。<br><img src="/images/2.png" alt=""></p>
<p>点击右侧的Environment标签，添加环境变量：</p>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐标题</th>
<th style="text-align:left">右对齐标题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>STATIC_SITE_REPO</code></td>
<td style="text-align:left">你的仓库地址</td>
</tr>
<tr>
<td style="text-align:left"><code>TARGET_BRANCH</code></td>
<td style="text-align:left">编译后文件存放的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>GIT_USER_EMAIL</code></td>
<td style="text-align:left">Github的用户邮箱</td>
</tr>
<tr>
<td style="text-align:left"><code>GIT_USER_NAME</code></td>
<td style="text-align:left">Github用户名</td>
</tr>
</tbody>
</table>
<p>如下图，然后点击一下下方的Save按钮。</p>
<p><img src="/images/3.png" alt=""></p>
<h4 id="第三步，获取Access-Token"><a href="#第三步，获取Access-Token" class="headerlink" title="第三步，获取Access Token"></a>第三步，获取Access Token</h4><p>访问个人设置页面：</p>
<p><img src="/images/4.png" alt=""></p>
<p>点击边栏下方的【Personal access tokens】选项卡，并点击右上方的【Generate new token】按钮。Token description任意填写，下方的选项中全选repo即可。</p>
<p>最后，点击下方绿色的【Generate token】按钮。此时就能得到你的Access Token。</p>
<p>也可以参考<a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/" target="_blank" rel="external">官方文档</a></p>
<h4 id="第四步，加密Access-Token"><a href="#第四步，加密Access-Token" class="headerlink" title="第四步，加密Access Token"></a>第四步，加密Access Token</h4><p>由于这个AccessToken是可以直接操作你的仓库的，而且配置文件是公开的，所以这时就要求对AccessToken进行加密。可到<a href="https://ci.appveyor.com/tools/encrypt" target="_blank" rel="external">AppVeyor Token加密页面</a>进行加密。把加密后的字符串填入下一步中的配置文件里。</p>
<h4 id="第五步，配置文件"><a href="#第五步，配置文件" class="headerlink" title="第五步，配置文件"></a>第五步，配置文件</h4><p>在Hexo的<strong>根目录</strong>下新建一个<code>appveyor.yml</code>文件，写下以下内容</p>
<pre class="line-numbers language-yaml"><code class="language-yaml">
<span class="token key atrule">clone_depth</span><span class="token punctuation">:</span> <span class="token number">5</span>

<span class="token comment" spellcheck="true"># 这里是限制了只编译有源文件的分支，这样在创建了其它分支时就不会再次编译了</span>
<span class="token key atrule">branches</span><span class="token punctuation">:</span>
  <span class="token key atrule">only</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> files

<span class="token key atrule">environment</span><span class="token punctuation">:</span>
  <span class="token key atrule">access_token</span><span class="token punctuation">:</span>
    <span class="token key atrule">secure</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#加密后的access_token</span>

<span class="token key atrule">install</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">ps</span><span class="token punctuation">:</span> Install<span class="token punctuation">-</span>Product node 6.0 <span class="token comment" spellcheck="true">#原始环境的node 是4.x的版本，最好升级到最新的版本，防止Hexo的插件无法安装</span>
  <span class="token punctuation">-</span> node <span class="token punctuation">-</span><span class="token punctuation">-</span>version
  <span class="token punctuation">-</span> npm <span class="token punctuation">-</span><span class="token punctuation">-</span>version
  <span class="token punctuation">-</span> npm install
  <span class="token punctuation">-</span> npm install hexo<span class="token punctuation">-</span>cli <span class="token punctuation">-</span>g

<span class="token key atrule">build_script</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> hexo generate

<span class="token key atrule">artifacts</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> public

<span class="token key atrule">on_success</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> git config <span class="token punctuation">-</span><span class="token punctuation">-</span>global credential.helper store
  <span class="token punctuation">-</span> <span class="token key atrule">ps</span><span class="token punctuation">:</span> Add<span class="token punctuation">-</span>Content "$env<span class="token punctuation">:</span>USERPROFILE\.git<span class="token punctuation">-</span>credentials" "https<span class="token punctuation">:</span>//$($env<span class="token punctuation">:</span>access_token)<span class="token punctuation">:</span>x<span class="token punctuation">-</span>oauth<span class="token punctuation">-</span>basic@github.com`n"
  <span class="token punctuation">-</span> git config <span class="token punctuation">-</span><span class="token punctuation">-</span>global user.email "%GIT_USER_EMAIL%"
  <span class="token punctuation">-</span> git config <span class="token punctuation">-</span><span class="token punctuation">-</span>global user.name "%GIT_USER_NAME%"
  <span class="token punctuation">-</span> git clone <span class="token punctuation">-</span><span class="token punctuation">-</span>depth 5 <span class="token punctuation">-</span>q <span class="token punctuation">-</span><span class="token punctuation">-</span>branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\static<span class="token punctuation">-</span>site
  <span class="token punctuation">-</span> cd %TEMP%\static<span class="token punctuation">-</span>site
  <span class="token punctuation">-</span> del * /f /q
  <span class="token punctuation">-</span> for /d %%p IN (*) do rmdir "%%p" /s /q
  <span class="token punctuation">-</span> SETLOCAL EnableDelayedExpansion &amp; robocopy "%APPVEYOR_BUILD_FOLDER%\public" "%TEMP%\static<span class="token punctuation">-</span>site" /e &amp; IF <span class="token tag">!ERRORLEVEL!</span> EQU 1 (exit 0) ELSE (IF <span class="token tag">!ERRORLEVEL!</span> EQU 3 (exit 0) ELSE (exit 1))
  <span class="token punctuation">-</span> git add <span class="token punctuation">-</span>A
  <span class="token punctuation">-</span> git commit <span class="token punctuation">-</span>m "Update Static Site"
  <span class="token punctuation">-</span> git push origin %TARGET_BRANCH%
  <span class="token punctuation">-</span> appveyor AddMessage "Static Site Updated"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大致的意思是从github仓库的当前分支拉取下来，编译成静态文件后，在push到目标分支。由于AppVeyor环境中是通过Access Token访问我们的仓库的，而Hexo自带的部署则在访问的过程中需要我们输入帐号密码，所以Hexo g -d的命令就不适合在这里使用。需要先编译成静态文件，再把public文件夹的静态文件push到目标分支。</p>
<p>最后，把这个文件提交到Github上就可以测试了！在AppVeyor的首页可以看到部署的过程和结果~</p>
<p><img src="/images/5.png" alt=""></p>
<p>别说我没告诉你，还可以添加一枚徽章装装逼哦！<a href="https://ci.appveyor.com/project/ElderJames/elderjames-github-io/branch/files" target="_blank" rel="external"><img src="https://ci.appveyor.com/api/projects/status/b0wack7uxrvifijj/branch/files?svg=true" alt="Build status"></a></p>
<p>可以看看我的<a href="https://github.com/ElderJames/elderjames.github.io/blob/files/appveyor.yml" target="_blank" rel="external">配置文件</a>，以及底部的两篇参考文章~</p>
<p>参考文章：</p>
<ul>
<li><a href="http://www.shong.win/blog/2017/02/19/hexo-ci/" target="_blank" rel="external">Hexo利用AppVeyor持续集成</a></li>
<li><a href="https://formulahendry.github.io/2016/12/04/hexo-ci/" target="_blank" rel="external">Hexo的版本控制与持续集成</a></li>
</ul>
<div id="aplayer0" class="aplayer" style="margin-bottom: 20px;width:400px;"></div>
		<script>
			new APlayer({
				element: document.getElementById("aplayer0"),
				narrow: false,
				autoplay: false,
				showlrc: 0,
				music: {
					title: "剩下的盛夏",
					author: "TF Boys",
					url: "http://dl.stream.qqmusic.qq.com/133751958.mp3?vkey=65AE8DE8D14CBE02883EBE1033D6E9127E077DBCAA4DAB55CF6DE2FA33A803BEAE739F1D56B6892BCA0EBCBF8C84BF7D47EC65652B06DEF0&guid=4082350140&fromtag=30",
					pic: "https://y.gtimg.cn/music/photo_new/T002R300x300M000001rvkpT0so9Uk.jpg?max_age=2592000",
				}
			});
		</script>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Appveyor </tag>
            
            <tag> CI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo! 从Ghost迁移博客到Hexo]]></title>
      <url>/migrate-blog-from-ghost-to-hexo-and-github.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>很高兴用上了hexo来搭建博客！</p>
<p>因为最近使用学习angular、vue、cordova等框架和技术，慢慢喜欢上了用node来构建应用程序的过程。我原来的博客系统是Ghost,部署在亚马逊AWS上。最近AWS一年免费体验准备到期了，博客也要找个别的地方安放。</p>
<p>早就知道了github上能搭建博客，但是之前是觉得构建起来很复杂，就没有尝试。这次，我就要尝试一下了！就是你现在看到的模样！</p>
<p>这篇文章要记下来整个迁移过程。从hexo的安装、构建、部署、安装主题、从Ghost迁移文章。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p><em><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">官方文档</a></em></p>
<ol>
<li>安装 <a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> 命令行输入 <code>npm</code>,有相关信息则安装成功 </li>
<li>安装 <a href="http://git-scm.com/" target="_blank" rel="external">Git</a> 命令行输入<code>Git</code>，有相关信息则安装成功</li>
<li><p>在命令行输入以下命令安装Hexo</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>初始化博客</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 初始化一个目录，&lt;folder>不填则为当前目录</span>
$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>
$ <span class="token function">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span>

<span class="token comment" spellcheck="true"># 安装依赖包</span>
$ <span class="token function">npm</span> <span class="token function">install</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>新建完成后，指定文件夹的目录如下：</p>
<pre><code>.
├── _config.yml   -&gt; 全局配置文件
├── package.json  -&gt; node的项目配置文件，用来配置依赖包和一些npm命令
├── scaffolds     -&gt; 模板文件夹。当您新建文章或页面时，Hexo 会根据 scaffold 来建立文件
├── source        -&gt; 资源文件夹是存放用户资源的地方,在里面创建文章、页面、图片等博客的内容
|   ├── _drafts   -&gt; 草稿文件夹
|   └── _posts    -&gt; 文章文件夹
└── themes        -&gt; 主题文件夹。Hexo 会根据主题来生成静态页面
</code></pre></li>
<li><p>输入以下命令，启动站点查看效果</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ hexo server
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果想更换端口，可以在命令后追加参数</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ hexo server -p 8080
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时在浏览器访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 就可以看到博客效果啦！</p>
<p>什么?默认主题不好看？别急，后面会讲如何安装主题~ 接下来介绍如何发布到Github！</p>
</li>
</ol>
<h2 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a>发布到GitHub</h2><p>接下来介绍如何把这个博客发布到Github Page。</p>
<p>Github Pages是Github为开源项目提供展示文档和示例的功能，有300M的空间，但只是放置静态文件，所以Hexo就必须先编译成静态文件，再push到Github Pages仓库。</p>
<ol>
<li><p>创建Github仓库，名称必须是[Github用户名].github.io,例如本博客的仓库 <a href="https://elderjames.github.io" target="_blank" rel="external">elderjames.github.io</a>,然后获得git仓库的地址，如<a href="https://github.com/ElderJames/elderjames.github.io.git" target="_blank" rel="external">https://github.com/ElderJames/elderjames.github.io.git</a></p>
</li>
<li><p>部署配置</p>
<p>在开始之前，您必须先在 _config.yml 中修改参数</p>
<pre class="line-numbers language-yml"><code class="language-yml">deploy:
 type: git
 repo: https://github.com/ElderJames/elderjames.github.io.git
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>命令行输入以下命令，安装部署工具 hexo-deployer-git</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>输入以下命令，编译并发布到Github</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy --generate
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em>这个命令是可以分开的，一个是编译静态文件，一个是发布，具体请<a href="https://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="external">参阅文档</a></em></p>
</li>
<li><p>如果成功提交到Github,则可以马上访问仓库名的那个地址 <a href="https://elderjames.github.io" target="_blank" rel="external">https://elderjames.github.io</a></p>
</li>
</ol>
<h2 id="尝试写一篇新文章"><a href="#尝试写一篇新文章" class="headerlink" title="尝试写一篇新文章"></a>尝试写一篇新文章</h2><pre class="line-numbers language-bash"><code class="language-bash">  $ hexo new <span class="token string">"My New Post"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>  主题在Github上有很多了，比如我现在安装这个，只要把主题文件复制到 themes 目录下，每个子目录代表一个主题。主题还能有很多扩展的设置，具体可能要参考主题的文档。</p>
<h2 id="从Ghost迁移文章"><a href="#从Ghost迁移文章" class="headerlink" title="从Ghost迁移文章"></a>从Ghost迁移文章</h2><p>  由于我之前的博客部署在 AWS 上，是 Ghost 博客系统，好处是文章用 markdown 编写，可以很好的迁移到 Hexo。</p>
<ol>
<li><p>从Ghost博客导出博客数据，几下保存的路径</p>
<p>访问 <a href="http://yourblog.com/ghost/debug/" target="_blank" rel="external">http://yourblog.com/ghost/debug/</a> , 点击 【导出】按钮下载一个 Json 文件。</p>
</li>
<li><p>安装迁移工具</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-migrator-ghost
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>输入以下命令导入文章到 Hexo, <code>&lt;source&gt;</code> 为第0步下载的json文件的路径。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ hexo migrate ghost <span class="token operator">&lt;</span>source<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p>然后，可以愉快得看到 <code>./source/_posts</code>（如果有草稿，则包括<code>./source/_dragts</code>）文件夹里已经出现了原来在 Ghost 中的文章。</p>
<p>好了，再执行一次 <code>hexo deploy --generate</code> 发布文章吧！！</p>
<p>别忘了互相关注哦！晚安！</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github Pages </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Visual Studio 2017 正式版安装问题及解决方案记录]]></title>
      <url>/visual-studio-2017-zheng-shi-ban-an-zhuang-wen-ti-ji-jie-jue-fang-an-ji-lu.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>##Visual Studio 2017正式版终于出来啦！</p>
<p>下载地址：<a href="https://www.visualstudio.com/zh-hans/" target="_blank" rel="external">请到主页</a></p>
<p>推荐使用安装器下载，速度比以前快了很多！必装的Web和.NET Core组件只需要15分钟就可以安装完（当然，视网速而定，15分钟是用100M/bs的宽带下载的，下载峰值在5M/s左右）</p>
<p>以下是记录了一些安装中遇到的问题，会不定时更新。</p>
<h4 id="Win7-无法安装Cordova"><a href="#Win7-无法安装Cordova" class="headerlink" title="Win7 无法安装Cordova"></a>Win7 无法安装Cordova</h4><p>因为Cordova组件需要PowerShell 6.0，而Win7是不自带的（Win8-Win10自带）,所以先下载PowerShell 6.0吧！</p>
<p><a href="https://www.microsoft.com/en-us/download/details.aspx?id=34595" target="_blank" rel="external">PowerShell 6.0下载地址</a></p>
<h4 id="Cordova-无法编译成Android"><a href="#Cordova-无法编译成Android" class="headerlink" title="Cordova 无法编译成Android"></a>Cordova 无法编译成Android</h4><p>可能是Gradle压缩包损坏导致，重新下载压缩包放到目录C:\Users\Administrator.gradle\wrapper\dists[gradle-2.13-all]下<br><a href="https://services.gradle.org/distributions/" target="_blank" rel="external">单独下载Gradle</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Visual Studio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NPM 国内镜像]]></title>
      <url>/n.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>npm由于很多时候都需要从国外的服务器下载组件，由于<strong>众所周知</strong>的原因，国内安装时往往会很慢甚至卡住安装不上的情况，这时就需要替换一下安装源，使用国内服务商提供的镜像：</p>
<ul>
<li><a href="http://npm.hacknodejs.com/" target="_blank" rel="external">http://npm.hacknodejs.com/</a></li>
<li><a href="http://registry.npmjs.vitecho.com/" target="_blank" rel="external">http://registry.npmjs.vitecho.com/</a></li>
<li><a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a></li>
</ul>
<p>####使用方法<br>永久使用镜像命令： </p>
<p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<p>临时使用镜像命令：</p>
<p><code>npm --registry &quot;http://npm.hacknodejs.com/&quot; install underscore</code></p>
]]></content>
      
        
        <tags>
            
            <tag> NPM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.NET Core中使用依赖注入获得请求生命周期内唯一的DbContext]]></title>
      <url>/asp-net-corezhong-shi-yong-qing-qiu-sheng-ming-zhou-qi-nei-wei-yi-de-dbcontext.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>很高兴，我的博客又回来了。</p>
<p>在使用.NET Core来开发项目已经有两个多月了，想在这里记录一些在.NET Core中比较方便的知识。</p>
<p>这里讲一讲在ASP.NET Core中使用依赖注入的方式请求生命周期内唯一的DbContext。<br>按照以往.NET Framework中的Web应用程序使用EF，我们会把DbContext实例放入CallContext中，这是在一个线程周期中可共享的存储对象，来达到获得线程内唯一的DbContext等其它对象。但是在.NET Core时代，已经不需要CallContext了，而是使用最突出的特点——依赖注入。</p>
<p>首先，我们在Startup.cs中配置好EF Core:</p>
<pre class="line-numbers language-asp.net"><code class="language-asp.net">services.AddDbContext<YourContext>(option =>
     option.UseMySql(Configuration.GetConnectionString("YunGoConllection"))
);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后，在需要的类中以构造方法注入的方式注入YourContext即可。注意：不管是在MVC项目中还是被应用的类库中，都可以使用注入方法！这就是.NET Core的强大~</p>
<pre class="line-numbers language-asp.net"><code class="language-asp.net">  public class TestController : Controller
    {
        YourContext _db;

        public TestController(YourContext db)
        {
            _db=db;
        }

        public async Task<IActionResult> Test()
        {
            var _users=await _db.Users.ToListAsync();
            return Ok(_users);
        }
     }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实在services.AddDbContext()内部，是已经用services.AddScoped()方法注册了YourContext，用这种方式注册后可以在一次请求生命周期内获得同一个实例，所以，我们可以把所有的注入都使用这种方式，节省因为每次都new对象（等同于注册方法services.AddTransient()）而带来的内存占用~</p>
]]></content>
      
        
        <tags>
            
            <tag> .NET Core </tag>
            
            <tag> .NET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[EF Core For Mysql 的DataBase First（基于已有数据库）方式连接数据库]]></title>
      <url>/ef-core-for-mysql-de-databasefang-shi-lian-jie-shu-ju-ku.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>.NET要跨平台，就一定要使用同样可以跨平台的数据库，而轻量的MySQL自然是首选。.NET Core发展到现在，虽然官方的Entity Framework还没发布MySQL版本，但是刚认识的柚子大神已经首先把它做出来了（<a href="http://www.1234.sh/post/pomelo-data-mysql" target="_blank" rel="external">他的博客</a>）。</p>
<p>同时，他也开源了它使用MySql for Entity Framework Core写的轻量博客系统，可惜在数据库连接是使用Code First。Code First当时是好，也是微软官方推荐的数据操作方式，可是，对于已有数据库的项目，希望创建基于已有数据库的.NET Core应用，或者对已有项目进行移植的开发者，就显得力不从心了。</p>
<p>虽然官方有从数据库创建模型的方法（<a href="https://docs.efproject.net/en/latest/platforms/aspnetcore/existing-db.html" target="_blank" rel="external">地址</a>），但是它使用了下面这三个只适用于SqlServer的工具包：</p>
<ul>
<li>Microsoft.EntityFrameworkCore.SqlServer</li>
<li>Microsoft.EntityFrameworkCore.Tools</li>
<li>Microsoft.EntityFrameworkCore.SqlServer.Design</li>
</ul>
<p>目前MySQL方面还没有这些工具包，就自然不能执行从数据库创建模型的命令（如下）了。</p>
<pre class="line-numbers language-bash"><code class="language-bash">Scaffold-DbContext <span class="token string">"Server=(localdb)\mssqllocaldb;Database=Blogging;Trusted_Connection=True;"</span> Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因此，我们目前只能手动创建模型，并且在DbContext中将模型与数据库中相应的表绑定起来，具体方法就是在DbContext中重写OnModelCreating方法：</p>
<pre class="line-numbers language-aspnet"><code class="language-aspnet">        protected override void OnModelCreating(ModelBuilder builder)
        {
            builder.Entity<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SliderPicture</span><span class="token punctuation">></span></span>(e =>
            {
                e.HasKey(x => x.Id);
                e.ToTable("yg_slider");
            });

            builder.Entity<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ClientVersion</span><span class="token punctuation">></span></span>(e =>
            {
                e.HasKey(x => x.Id);
                e.ToTable("yg_version")
                .HasIndex(x => x.CreateTime);
            });
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>希望.NET Core能尽快完善并增加更强大的特性，我想这也是所以.NETer的希望。</p>
]]></content>
      
        
        <tags>
            
            <tag> .NET Core </tag>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[.NET Core以依赖注入的方式配置MySql的DbContext]]></title>
      <url>/yi-zhu-ru-de-fang-shi.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>使用ASP.NET Core开发Web项目，在很多方面都跟之前的.NET版本有很大不同，在Startup.cs的配置方面,一言不合就使用依赖注入。当然，这对于整个项目的解耦是极好的。这次踩的坑在DbContext的配置上。</p>
<p>在<a href="http://www.1234.sh/post/pomelo-data-mysql" target="_blank" rel="external">柚子大神的博客</a>中,有介绍他移植过来的mysql for ef core的使用方法是在Startup中注册服务：</p>
<pre class="line-numbers language-aspnet"><code class="language-aspnet">services.AddDbContext<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>YourContext</span><span class="token punctuation">></span></span>(x => x.UseMySql("server=localhost;database=yourdb;uid=root;pwd=yourpwd"));
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是，这样配置之后，又需要在YourContext中配置：<br><img src="/content/images/2016/07/0e1ef77c-b03e-439f-a894-cb1de1811695.png" alt=""></p>
<p>这样的话，其实是等于配置了两次，在DbContext中是直接写ConnectionString的，不能（我还不会）从配置文件中读取。因此，需要寻找一个从Startup中配置的有效方法。</p>
<p>通过对比MVC6项目模版的sqlserver配置方式，和<a href="https://docs.efproject.net/en/latest/miscellaneous/configuring-dbcontext.html" target="_blank" rel="external">官方文档的介绍</a>，发现DbContext里是可以通过注入的方式注册ConnectionString的，方法就是设置构造函数注入DbContextOptions：</p>
<pre class="line-numbers language-aspnet"><code class="language-aspnet">  public YourContext(DbContextOptions<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>YourContext</span><span class="token punctuation">></span></span> options)
            : base(options)
        { }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      
        
        <tags>
            
            <tag> .NET Core </tag>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用SecureCRT连接免费的亚马逊云服务器]]></title>
      <url>/shi-yong-securecrtlian-jie-ya-ma-xun-yun-fu-wu-qi.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>亚马逊AWS有一年的免费体验，相比国内的阿里云、腾讯云的优惠政策更实在，而且又不用认证、也不用备案，一个邮箱帐号就能获得，简直就是我等学生（虽然已经不是了，但刚出来工作没几个钱呀！）的福利！</p>
<p>在亚马逊中，选择“新加坡”、“首尔”、“东京”这几个位于亚洲的节点响应速度都算是比较快的，虽然比不上国内，但是结合七牛等CDN云服务一样可以做到不错的响应速度。</p>
<p>而本篇的主题，就是因AWS的特殊连接方式而产生的，虽然网上已经有很多前辈给了教程，但是始终不如自己写一下，等以后可以方便地查到更方便。</p>
<h6 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h6><ol>
<li>创建AWS实例的时候，会得到一个.pem后缀的密钥文件，我们需要通过这个文件去连接服务器。</li>
<li>打开SecureCRT，点击菜单栏“工具”–&gt;“转换密钥为OpenSHH格式”,然后在弹出的文件选择框中选择pem文件，然后在接下来的文件选项框中选择保存转换后密钥对文件的保存路径，这样密钥就保存完了。</li>
<li>点击“快速连接”按钮，在弹出的“快速连接”窗口中，输入“服务器ip地址”，不输入用户名，在“鉴权”一栏，把“公钥”移动到第一位，即“密码”上面。</li>
<li>选择“公钥”，然后点击“属性”，再选择“使用会话公钥设置”，在会话设置中选择“使用身份或证书文件”，并点击“…”按钮选择第2步生成的.pub文件。</li>
<li>最后点击“确定”，并在“快速连接”窗口中点击“连接”，然后在弹出的提示框中点击“是”，此时就已经可以成功连接到服务器了。</li>
</ol>
<h6 id="改为使用密码登录"><a href="#改为使用密码登录" class="headerlink" title="改为使用密码登录"></a>改为使用密码登录</h6><p>使用密钥文件连接，虽然是大大加强安全性了，但是对于个人服务器来说就很不方便了，所以，这里把前辈们给出的方法搬过来。</p>
<ol>
<li><p>修改ROOT密码<br><code>sudo passwd root</code></p>
</li>
<li><p>修改sshd_config文件的限权，用完再把权限改回来<br><code>sudo chmod 777 /etc/ssh/sshd_config</code></p>
</li>
<li><p>使用vi编辑<code>vi /etc/ssh/sshd_config</code> </p>
<ul>
<li><code>PermitRootLogin</code> 改为 PermitRootLogin yes</li>
<li><code>PasswordAuthentication no</code>  no 改为 yes</li>
<li><code>UsePAM yes</code> yes改为no （CentOS此步不需做）</li>
</ul>
</li>
<li><p>执行<code>/etc/init.d/sshd restart</code>或到AWS控制台重启服务器。</p>
</li>
</ol>
<p>这样就搞定啦！！</p>
<h6 id="使用WinSCP连接"><a href="#使用WinSCP连接" class="headerlink" title="使用WinSCP连接"></a>使用WinSCP连接</h6><p>对于不习惯命令行的我，文件操作还是使用GUI比较方便，在这方面，WinSCP有绝对的口碑，而使用密钥文件来连接的话，还是要多一些步骤。</p>
<ol>
<li>新建站点，点击高级按钮，在弹出的“高级站点设置”窗口中，选择“验证”设置项，在“验证参数”选项中点击“…”按钮，选择.pem文件，此时会有将.pem文件转换为PuTTY格式的密钥文件的提示，点击“确定”就好了。</li>
<li>在弹出的“PuTTY Key Generator”窗口中，如果希望使用密钥文件登录时还需要密码才能登录，可以在“KeyPassphrase”输入框中输入密码和确认密码，然后点击“Save Private Key”按钮，在不填密码时会弹出提示，如果确定不用密码就可以直接点击“是”，这时会保存一个.ppk文件到选定的目录。</li>
<li>然后回到“高级站点设置”窗口，重复第一步，不过此时选择的是刚刚生成的.ppk文件，点击“确定”按钮回到登录界面。</li>
<li>登录界面输入主机名，最后点击“登录”按钮即可成功登录。</li>
</ol>
<p>好啦，关于亚马逊AWS的使用就写到这吧~~</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Amazon AWS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[.NET Core 资料整理]]></title>
      <url>/net-core-zi-liao-zheng-li.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>##工具下载</p>
<ul>
<li><p><a href="http://download.microsoft.com/download/c/2/6/c26892d8-6a5d-4871-9d46-629f4d430146/vs2015.3.vsu.iso" target="_blank" rel="external">Visual Studio 2015 Update3 升级包</a></p>
</li>
<li><p><a href="ed2k://|file|cn_visual_studio_professional_2015_with_update_3_x86_x64_dvd_8923256.iso|7745202176|DD35D3D169D553224BE5FB44E074ED5E|/" target="_blank" rel="external">Visual Studio Professional 2015 Update3</a></p>
</li>
<li><p><a href="http://download.microsoft.com/download/7/c/f/7cf151c3-b735-4e35-a1bb-9a48224f4a95/vs2015.3.ent_chs.iso" target="_blank" rel="external">Visual Studio Enterprise 2015 Update3</a> </p>
</li>
<li><p><a href="http://download.microsoft.com/download/5/d/1/5d1ec81e-bc59-448f-9ab6-27636d5cc18a/vs2015.3.com_chs.iso" target="_blank" rel="external">Visual Studio Community 2015 Update3</a></p>
</li>
<li><p><a href="http://download.microsoft.com/download/A/3/8/A38489F3-9777-41DD-83F8-2CBDFAB2520C/DotNetCore.1.0.0-VS2015Tools.Preview2.exe" target="_blank" rel="external">.NET Core for VS Tools</a></p>
</li>
<li><p><a href="https://az764295.vo.msecnd.net/stable/e724f269ded347b49fcf1657fc576399354e6703/VSCodeSetup-stable.exe" target="_blank" rel="external">Visual Studio Code</a></p>
</li>
<li><p><a href="https://download.microsoft.com/download/A/3/8/A38489F3-9777-41DD-83F8-2CBDFAB2520C/packages/DotNetCore.1.0.0-SDK.Preview2-x64.exe" target="_blank" rel="external">.NET Core SDK</a></p>
</li>
</ul>
<p>##文档</p>
<ul>
<li><a href="http://www.cnblogs.com/dotNETCoreSG/p/aspnetcore-index.html" target="_blank" rel="external">ASP.NET Core 中文文档</a></li>
</ul>
<p>##部署</p>
<ul>
<li><a href="http://www.cnblogs.com/yunei/p/5662642.html" target="_blank" rel="external">Jexus 5.8.2 Beta1发布：为Asp.Net Core进入生产环境提供平台支持</a></li>
<li><a href="http://www.cnblogs.com/gaobing/p/5663012.html" target="_blank" rel="external">ASP.NET Core “完整发布,自带运行时” 到jexus</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> .NET Core </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记在Mono 4.2 上EF使用Select操作时会发生的错误]]></title>
      <url>/yun-xing-zai-monoshang-de-efyun-xing-cuo-wu.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>错误提示：The classes in the module cannot be loaded.</p>
<p>代码还原：</p>
<pre class="line-numbers language-aspnet"><code class="language-aspnet"> var data = await db.Set<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FormulaCarType</span><span class="token punctuation">></span></span>()
.Where(c => c.Status == (int)CommonStatus.启用)
.Select(c => new FormulaCarModel
            {
                Id = c.Id,
                Type = c.CardType,
                Seats = c.Seats,
                FuelConsumption = c.FuelConsumption,
                MaintainFee = c.MaintainFee,
                CreateTime = c.CreateTime,
                Status = (CommonStatus)c.Status
            }).ToListAsync();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在查询中，在查询方法（ToListAsync）执行前进行了select的操作，则在执行的时候就会出错（在Windows上运行时不会发生），因此，需要在select前执行查询，再对查询结果进行select的操作。如下则不会出错：</p>
<pre class="line-numbers language-aspnet"><code class="language-aspnet">var result = await db.Set<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FormulaCarType</span><span class="token punctuation">></span></span>()
.Where(c => c.Status == (int)CommonStatus.启用).ToListAsync();
 var data = result.Select(c => new FormulaCarModel
            {
                Id = c.Id,
                Type = c.CardType,
                Seats = c.Seats,
                FuelConsumption = c.FuelConsumption,
                MaintainFee = c.MaintainFee,
                CreateTime = c.CreateTime,
                Status = (CommonStatus)c.Status
            });
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> mono </tag>
            
            <tag> EF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.NET Core使用Session方法]]></title>
      <url>/as.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><ul>
<li><p>在project.json配置文件中引入程序集：<code>&quot;Microsoft.AspNetCore.Session&quot;: &quot;1.0.0&quot;</code></p>
</li>
<li><p>在Startup.cs的ConfigureService方法中加入以下代码：</p>
<pre><code>services.AddSession(options =&gt; {
  options.IdleTimeout = TimeSpan.FromMinutes(30);
} );
</code></pre></li>
<li>在Configure方法中加： <code>app.UseSession();</code></li>
</ul>
<p>于是，Session就可以用啦！</p>
]]></content>
      
        
        <tags>
            
            <tag> .NET Core </tag>
            
            <tag> .NET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从旧版.NET Core 升级到.NET Core 1.0正式版]]></title>
      <url>/cong-jiu-ban-net-core-sheng-ji-dao-net-core-1-0zheng-shi-ban.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>6月28日凌晨，RedHat 开发者大会上微软正式发布.NET Core正式版，我作为.NET爱好者，马上就想安装来玩玩，不过因为之前电脑上就装有旧版本，在这次正式版的安装中遇到了一些坑，装了n遍，死活装不上，停留在旧版本。</p>
<p>下载地址：</p>
<ol>
<li><a href="https://go.microsoft.com/fwlink/?LinkId=817245" target="_blank" rel="external">.NET Core for Visual Studio official MSI Installer</a><br>(需要先安装<a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" target="_blank" rel="external">Visual Studio 2015 Update 3</a>)</li>
<li><a href="https://go.microsoft.com/fwlink/?LinkID=809122" target="_blank" rel="external">.NET Core SDK for Windows</a></li>
</ol>
<p>然后，如果你电脑之前没安装过.NET Core,有装了Visual Studio 2015 的话，需要把VS升级到Update3，再安装.NET Core for Visual Studio official MSI Installer（里面已经包含.NET Core SDK）； 如果没装VS，也不打算使用VS的话，可以只安装.NET Core SDK。</p>
<p>但是，如果以前安装过旧版的.NET Core，就需要先在【控制面板\所有控制面板项\程序和功能】中卸载以前的版本，并且==需要删除所有的环境变量==，在【控制面板\所有控制面板项\系统】中的左侧边栏中点击【高级系统设计】，在弹出的窗口中点击下方的环境变量按钮，在弹出的【环境变量】窗口中的【系统变量】一栏中找到“Path”变量，删除所有指向dotnet、dnx、dnu、dnvm目录的值，然后按“确定”保存退出。</p>
<p>这样，安装程序才能重新安装新版的.NET Core SDK。在命令提示符窗口中输入<code>dotnet</code>命令即可查看到当前版本是否为正式版1.0.1。</p>
<p>谢谢大家！</p>
]]></content>
      
        <categories>
            
            <category> .NET Core </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET Core </tag>
            
            <tag> .NET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git 操作笔记]]></title>
      <url>/git-cao-zuo-bi-ji.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><code>$ cd myproject</code>  你建立的项目文件夹</p>
<p><code>$ git init</code>   执行git的本地初始化</p>
<p><code>$ git add .</code>  将所有的文件添加到版本控制系统</p>
<p><code>$ git commit -m &quot;initial commit&quot;</code>  在本地提交到版本库</p>
<p><code>$ git remote add origin git@116.255.160.144://srv/gitserver/jewels.git</code> 添加远程仓库(jewels是服务器端项目管理到名字，与本地项目名字无关)</p>
<p><code>$ git push origin master</code> 将本地版本库推送到远程仓库</p>
<p><code>git checkout master</code> //进入master分支</p>
<p><code>git checkout -b frommaster</code> //以master为源创建分支frommaster</p>
<p>// 把本地仓库提交到远程仓库的master分支中</p>
<p><code>git push ssh://git@dev.lemote.com/rt4ls.git master</code> </p>
<p>或使用标记</p>
<p><code>$ git remote add origin ssh://git@dev.lemote.com/rt4ls.git</code></p>
<p><code>$ git push origin master</code></p>
<p><code>$ git push origin test:master</code>         // 提交本地test分支作为远程的master分支</p>
<p><code>$ git push origin test:test</code>             // 提交本地test分支作为远程的test分支</p>
<p><code>$ git push origin :test</code>              // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心</p>
<p>文章来源：<a href="http://www.cnblogs.com/wangkangluo1/archive/2011/09/02/2164313.html" target="_blank" rel="external">git 远程分支创建与推送</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 搭建Gogs ：轻量Git Web端管理系统]]></title>
      <url>/ubuntu-da-jian-gogs-qing-liang-git-webduan-guan-li-xi-tong.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Gogs是国人开发的开源git管理系统，类似gitlab，可在服务器上搭建私人的git版本管理系统。内建很多功能，但俾比gitlab安装更方便，占用更少的资源。<br>详细介绍还是看看官方网站吧：<a href="https://gogs.io" target="_blank" rel="external">https://gogs.io</a></p>
<p>现在结合本人的安装过程，在这里做一个记录。适合小白参考。</p>
<p>安装方法有三种：二进制安装，源码安装，包管理安装，我认为最方便的还是二进制安装。</p>
<p>首先下载<a href="https://gogs.io/docs/installation/install_from_binary" target="_blank" rel="external">二进制包</a>，在这个页面上也有安装教程。</p>
<p>然后在解压后进入目录，执行 ./gogs web ，则能够启动服务进程，但这时的服务是临时的，一退出就会关闭，所以需要持续化进程配置。</p>
<p>因为gogs的安装设置页面里的设置只能设置一次，以后要修改则要新建一个文件，所以这里最好先做好准备工作。</p>
<ul>
<li>反向代理 代理ip为 <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a></li>
<li>持续进程 使用supervisor</li>
</ul>
<p><code>sudo apt-get -y install supervisor</code></p>
<p><code>sudo mkdir -p /var/log/gogs</code></p>
<p><code>sudo nano /etc/supervisor/supervisord.conf</code></p>
<p>在这个文件最下面添加应用信息</p>
<pre><code>[program:gogs]
directory=/home/gogs/
command=/home/gogs/gogs web
autostart=true
autorestart=true
startsecs=10
stdout_logfile=/var/log/gogs/stdout.log
stdout_logfile_maxbytes=1MB
stdout_logfile_backups=10
stdout_capture_maxbytes=1MB
stderr_logfile=/var/log/gogs/stderr.log
stderr_logfile_maxbytes=1MB
stderr_logfile_backups=10
stderr_capture_maxbytes=1MB
environment = HOME=&quot;/home/git&quot;, USER=&quot;git&quot;
user = git
</code></pre><p>其中directory和command中的路径是gogs目录的路径</p>
<p>最后执行重启服务<br><code>sudo service supervisor restart</code></p>
<p>提示Starting supervisor: supervisord.</p>
<p>然后执行<code>ps -ef | grep gogs</code>查看服务是否已经启动</p>
<p>如果有如下类似信息则表示服务启动成功：</p>
<p>root      1344  1343  0 08:55 ?        00:00:00 /home/gogs/gogs web</p>
<p>这个时候，可以在浏览器上访问<code>http://your_server_ip:3000/</code>或者在反向代理中设置好的地址，自动跳转到/install设置页面。其中要注意的是网址设置，如果已经使用反向代理，则添加设置的地址，应用域名不需要http:// ，而后面的应用url则需要http:// ，否则路由会出错。</p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
            <tag> gogs </tag>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[修复apt-get包管理]]></title>
      <url>/xiu-fu-apt-getbao-guan-li.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>1.通过<code>wget http://oss.aliyuncs.com/aliyunecs/update_source.tgz</code> 下载update_source的压缩包。</p>
<p>2.<code>tar xvf update_source.tgz</code>解压后予执行权限<code>chmod 777 update_source.sh</code>。</p>
<p>3.执行该脚本<code>./update_source.sh</code>进行自动变更源操作。</p>
<p><img src="https://img.alicdn.com/tps/TB1tGPGJFXXXXbwXVXXXXXXXXXX-878-324.jpg" alt=""><br><img src="https://img.alicdn.com/tps/TB1Fsr1JFXXXXcFXpXXXXXXXXXX-810-184.jpg" alt=""></p>
<p>更新成功会提示”Success, exit now!“</p>
<p>如问题还未解决,请联系售后技术支持。</p>
<p>来源：<a href="http://www.iisiis.com/web/vps/1884.html" target="_blank" rel="external">http://www.iisiis.com/web/vps/1884.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C#利用反射机制动态创建泛型接口实例]]></title>
      <url>/dong-tai-chuang-jian-fan-xing-jie-kou-shi-li.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我很懒，不希望写重复的copy代码，所以希望在写代码时能尽量简化和重用，一些设计上有但没必要的能不写就不写，但当然必须要实现。</p>
<p>最近学会用C#的反射机制，觉得非常好，可以通过类名实例化一个对应的对象。于是我就想到了在设计业务层时，一些通用的数据库操作是以泛型基类的形式供给各个模型使用的，只需替换传入的模型的类型参数，即刻操作相应的模型，而对于一些模型需要的特殊操作，则以这个基类派生出包含特殊方法的子类来实现。</p>
<p>但是这里会出现一些问题，就是在各层透明的情况下，其他层是不知道模型是否包含有特殊的方法，最初的解决方法是为每个模型都写一个继承业务基类的子类，就算它里面是空的（没有特殊方法）。而现在，通过反射，我们可以很好地实现统一的业务实例化操作，实现自动判断该模型是否拥有对应的业务子类。</p>
<p>先设计一个泛型接口<code>IService&lt;T&gt;</code>,声明两个方法：</p>
<pre><code>namespace Service
{
   public Interface IService&lt;T&gt; where T : class
   {

      IRepository&lt;T&gt; _repo { get; }
      void SetRespository(IRepository&lt;T&gt; repo);
      T Add(T entity);
      bool Update(T entity);
   }
}
</code></pre><p>然后再写一个基础类，继承这个接口：</p>
<pre><code>namespace Service
{
      public class BaseService&lt;T&gt; : IService&lt;T&gt; where T : class
    {
        IRepository&lt;T&gt; _repo ;
        public void SetRespository(IRepository&lt;T&gt; repo)
        {
            _repo=repo;
        }
        public T Add(T entity){}
        public bool Update(T entity){}
    }
}
</code></pre><p>设计业务工厂类，提供统一的实例化出口</p>
<pre><code>    /// &lt;summary&gt;
    /// 业务工厂类
    /// &lt;para&gt;所有业务类都必须从这里产生&lt;/para&gt;
    /// &lt;/summary&gt;
    public class ServiceFactory
    {
        //获取当前程序集中的所有类的类型
        static Type[] ts = Assembly.GetExecutingAssembly().GetTypes();

        /// &lt;summary&gt;
        /// 动态映射创建实现了IService&lt;T&gt;接口的实例
        /// &lt;para&gt;如果字符集中已有继承了BaseService&lt;T&gt;的类，则返回该类的实例,
        /// 否则返回BaseService&lt;T&gt; 的实例&lt;/para&gt;
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;数据模型&lt;/typeparam&gt;
        /// &lt;param name=&quot;repo&quot;&gt;仓储实例&lt;/param&gt;
        /// &lt;returns&gt;实现IService&lt;T&gt;接口的实例对象&lt;/returns&gt;
        public static IService&lt;T&gt; GetService&lt;T&gt;(IRepository repo) where T : class
        {
            //获取传入类型的 System.Type 对象
            Type TType = typeof(T);
            //取当前线程内存块中可能已存储的Service对象
            var _service = CallContext.GetData($&quot;BaseService&lt;{TType.Name}&gt;&quot;) as IService&lt;T&gt;;

            if (_service != null) return _service;
            //查询扩展业务类是否存在于程序集中
            Type _class = ts.FirstOrDefault(o =&gt; o.Name.Equals(TType.Name + &quot;Service&quot;));
            try
            {
                if (_class != null)
                {
                    _service = Activator.CreateInstance(_class) as IService&lt;T&gt;;
                }
                else
                {
                    _service = Activator.CreateInstance(typeof(BaseService&lt;T&gt;)) as IService&lt;T&gt;;
                }
            }
            catch (Exception ex)
            {
                throw new Exception($&quot;无法实例化{typeof(BaseService&lt;T&gt;).Name}:{ex.Message}&quot;);
            }

            //获取泛型类定义的type类型
            var _repoType = repo.GetType().GetGenericTypeDefinition();
            //传入泛型类型参数
            _repoType = _repoType.MakeGenericType(typeof(T));
            //实例化仓储类
            var _repo = Activator.CreateInstance(_repoType) as IRepository&lt;T&gt;;
            //注入DbContext
            _repo.SetDbContext(repo.db);
            //注入仓储类
            _service.SetRespository(_repo);

            //将对象保存到当前线程的内存块中
            CallContext.SetData($&quot;BaseService&lt;{TType.Name}&gt;&quot;, _service);
            return _service;
        }
    }
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu安装mono 4.2.1 最新版教程]]></title>
      <url>/the-lastest-way-to-install-mono-4-2-1-on-ubuntu.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>现在安装mono已经不用make命令来编译，可以直接执行<code>apt-get mono-complete</code>来安装最新的mono版本。</p>
<p>下面看看怎么安装：</p>
<ul>
<li>首先，在mono-project的安装指南页面获得最新的注册信息，<br><a href="http://www.mono-project.com/docs/getting-started/install/linux/#debian-ubuntu-and-derivatives" target="_blank" rel="external">这是地址</a>。</li>
</ul>
<p>然后按照上面的命令执行</p>
<p><code>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF</code></p>
<p><code>echo &quot;deb http://download.mono-project.com/repo/debian wheezy main&quot; | sudo tee /etc/apt/sources.list.d/mono-xamarin.list</code></p>
<p><code>sudo apt-get update</code></p>
<p>然后，再执行</p>
<p><code>sudo apt-get install mono-complete</code></p>
<p>OK,完成。不用再等久久的编译咯！</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> mono </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.NET 连接 Mysql 支持中文编码]]></title>
      <url>/make-mysql-support-chinese-encoding.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>1、关闭mysql服务<br><code>service mysql stop</code></p>
<p>2、修改 /etc/mysql/my.cnf  （默认的安装路径）<br><code>vim /etc/mysql/my.cnf</code></p>
<p>3、打开my.cnf后，在文件内的[mysqld]下增加如下两行设置:</p>
<pre><code>character-set-server=utf8
collation-server=utf8_general_ci
</code></pre><p><img src="http://" alt=""></p>
<p>保存并退出。</p>
<p>4、重新启动mysql服务<br><code>service mysql start</code></p>
<p>5、连接字符串加入<code>CharSet=utf8;</code></p>
]]></content>
      
        
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.NET MVC 中UEditor 1.4.3 前台直接上传文件到七牛云存储]]></title>
      <url>/use-qiniu-upload-file-service-on-ueditor-for-asp-net-mvc.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近在做一个ASP.NET MVC 的项目，当然是离不开富文本编辑器，这里我选择的是百度的UEditor，虽然不够轻量，界面也不好看，但是功能还是挺多的。而因为项目主要面对移动端的用户，所以为了减轻低配服务器的压力，也为了用户体验更佳，决定在项目中接入七牛云存储。</p>
<p>选择七牛是看重他的CDN、上传加速和图片处理功能，最神奇的是在获取图片时只需在Url中加入几个参数即刻，而且还可以自己定图片的大小，大大减少了服务器在图片处理上的压力。</p>
<p>好吧，在这里就不继续安利了。</p>
<p>我第一次直接在项目中接入七牛，所以还是碰到了很多障碍。过程我就先不说了，我直接说怎么修改UEditor的相关代码吧。</p>
<p>###前台部分</p>
<ul>
<li><p>在配置文件config.json中，修改替换所有的<code>upfile</code> 为<code>file</code>，这里是因为七牛的上传接口要求文件上传控件（input）的name为file。</p>
</li>
<li><p>然后在最后加上几个配置项：</p>
<pre><code>
  /*七牛配置*/
  &quot;access_key&quot;: &quot;&quot;,
  &quot;secret_key&quot;: &quot;&quot;,
  &quot;bucket&quot;: &quot;mybucket&quot;,
  &quot;domain&quot;: &quot;http://xxx.com/&quot;,//七牛默认域名或者自定义域名
  &quot;uploadUrl&quot;:&quot;http://upload.qiniu.com/&quot;,//七牛上传文件的域名
  &quot;imageFieldName&quot;: &quot;file&quot;, /* 提交的图片表单名称 */
  &quot;tokenAction&quot;: &quot;/Admin/Attachment/Token&quot;,//获取上传凭证token的Action
</code></pre></li>
<li><p>在路径 ueditor/dialogs/image/image.js 中找到<code>header[&#39;X_Requested_With&#39;] = &#39;XMLHttpRequest&#39;;</code> 在下面添加以下代码：</p>
</li>
</ul>
<pre><code>  var filename = file.file.name;
  var token = &quot;&quot;;
  console.log(filename);
  $.ajax({
       dataType: &#39;text&#39;,
       async: false,
       url: editor.getOpt(&#39;tokenAction&#39;) + &quot;?file=&quot; + filename+&quot;&amp;type=img&quot;,
       success: function (data) {
           oken = data;
       }
   });
   data[&#39;token&#39;] = token;
</code></pre><ul>
<li><p>在这段代码的上面，找到<code>uploader.option(&#39;server&#39;, url);</code><br>注释并修改为<code>uploader.option(&#39;server&#39;,editor.getOpt(&#39;uploadUrl&#39;));</code></p>
</li>
<li><p>在这段代码下面寻找<code>uploader.on(&#39;uploadSuccess&#39;, function (file, ret) {</code>，并在这个方法中的<code>if (json.state == &#39;SUCCESS&#39;) {</code>增加一行代码：</p>
<pre><code>    //在返回的地址加上七牛设置里的域名
    json.url = editor.getOpt(&#39;domain&#39;) + json.url;
</code></pre></li>
<li><p>另外在attachment.js、video.js 的相同地方按上面所说的修改。</p>
</li>
</ul>
<p>###后台部分</p>
<ul>
<li><p>引入Qiniu SDK,添加一个获取token的服务:</p>
</li>
<li><p>添加获取token的Action（事先已经含有UEditor SDK的代码）：<br><img src="http://cdn.blog.yangshunjie.com/image/2/80/e2d2079f10dae2c8d51d0b96fe131.png" alt=" "></p>
</li>
<li><p>OssService.cs 中相关代码</p>
</li>
</ul>
<p><img src="http://cdn.blog.yangshunjie.com/image/d/b4/cbafea85536df7484629196a29cd6.png" alt=""><br><img src="http://cdn.blog.yangshunjie.com/image/4/18/4538ae76b6e196c09489c059a8651.png" alt=""></p>
<p>这样就基本可以实现将图片上传到七牛的空间了。而如果想在自己的服务器保留一份文件，可以在token中加如CallbackUrl 和 CallbackBody，使七牛在上传完成后对本地的服务器发出请求，把文件的参数发到本地服务器，这时本地服务器即刻按照返回的文件路径将文件抓取到本地服务器中。这部分我还没着手做，下次再继续写吧！</p>
]]></content>
      
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 七牛 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ghost博客邮件SMTP服务配置]]></title>
      <url>/the-smtp-setting-for-ghost-blog.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>前天由于回到学校，用回了我的Pocker2机械键盘，在输入密码时连续不知道大小写切换键换了地方，连续输错了密码，帐号被封了……</p>
<p>Ghost也是的，连博客主人的号都能封，还不能（也可能是我不会）通过操作服务器（比如Wordpress能通过删除配置文件）来重置密码，只能通过发送邮件，好吧，之前就一直配置不成功，现在好了，只能硬着头皮给它设置好了。</p>
<p>看过几篇关于配置邮箱的文章，但还是不行，我就以为是我人品不好了。但是今天重新看了配置文件之后，终于发现了我错在哪，所以现在记录一下吧。</p>
<p>其实问题就在于<strong>填写mail配置的地方不对</strong></p>
<p>之前我是替换了<code>development</code>节点里的配置。其实，正确的地方是在开头第一个节点<code>production</code>里的<code>mail:{}</code>,把它替换成配置的信息就好了。（这可能跟node.js运行模式的选择有关，我在第一篇文章里有提过，在守护进程里设置的是<strong>production</strong>）</p>
<p>配置代码片段如下：</p>
<pre><code>mail: {
         transport: &#39;SMTP&#39;,
         from: &#39;杨舜杰博客 &lt;blog@yangshunjie.com&gt;&#39;, //发件人
         options: {
              host: &#39;smtp.yangshunjie.com&#39;,//我已经将自己的域名绑定到了阿里云的企业邮箱
              secureConnection: false, //不使用SSL                     
              port: 25,//端口
              auth: {
                  user: &#39;blog@yangshunjie.com&#39;, //邮箱地址
                  pass: &#39;********&#39;  //密码
              }
          }
      },
</code></pre><p>最后重启一下ghost,一按找回密码，好了，收到邮件了，密码重置了，这篇博文也写完了。</p>
]]></content>
      
        
        <tags>
            
            <tag> ghost </tag>
            
            <tag> smtp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Framework7多视图（View）工具栏布局]]></title>
      <url>/the-multiple-views-structure-on-framework7.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>HiApp 可以算是一个比较完整的App，其中有很多能够学习的地方，比如它用的RequireJS 、它的界面交互等等，而对于初学者来说，它的布局结构是很值得学习的。因为它的结构是目前绝大多数App的常用布局，分为顶部导航栏Navbar，中 部多个视图View，底部是切换view的工具栏Toolbar。</p>
<p>它的特殊之处在于在界面首层显示了工具栏，而且4个view的底部都是给工具栏空出了位置，而进入到第二层以后，就自动隐藏了工具栏，view内的页 面没有给工具栏留出位置。这是一个很巧妙的结构。</p>
<p>在文档里，介绍的布局实例里都没有提及这种布局，所以我才说应该去学习。</p>
<p>但是由于HiApp的模块化结构使得它不易看懂，经过我自己的试验，终于做出了效果大致相同的结构。</p>
<p>用到的结构html是：</p>
<pre><code>&lt;div class=&quot;views  navbar-through tabs&quot;&gt;
    &lt;div id=&quot;view-1&quot; class=&quot;view tab active&quot;&gt;
        &lt;div class=&quot;navbar&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;pages&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id=&quot;view-2&quot; class=&quot;view tab&quot;&gt;
        &lt;div class=&quot;navbar&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;pages&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id=&quot;view-3&quot; class=&quot;view tab&quot;&gt;
        &lt;div class=&quot;navbar&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;pages&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id=&quot;view-4&quot; class=&quot;view tab&quot;&gt;
        &lt;div class=&quot;navbar&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;pages&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- Bottom Toolbar--&gt;
    &lt;div class=&quot;bottom-toolbar toolbar tabbar tabbar-labels toolbar-hidden&quot;&gt;
        &lt;div class=&quot;toolbar-inner&quot;&gt;
            &lt;a href=&quot;#view-1&quot; class=&quot;link tab-link active&quot;&gt;
                &lt;i class=&quot;icon-table icon-2x&quot;&gt;&lt;/i&gt;
                &lt;span class=&quot;tabbar-label&quot;&gt;课表&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;#view-2&quot; class=&quot;link tab-link&quot;&gt;
                &lt;i class=&quot;icon icon-book icon-2x&quot;&gt;
                    &lt;span class=&quot;badge bg-red&quot;&gt;4&lt;/span&gt;
                &lt;/i&gt;
                &lt;span class=&quot;tabbar-label&quot;&gt;读书&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;#view-3&quot; class=&quot;link tab-link&quot;&gt;
                &lt;i class=&quot;icon icon-compass icon-2x&quot;&gt;&lt;/i&gt;
                &lt;span class=&quot;tabbar-label&quot;&gt;发现&lt;/span&gt;
            &lt;/a&gt;
            &lt;a href=&quot;#view-4&quot; class=&quot;link tab-link&quot;&gt;
                &lt;i class=&quot;icon icon-user icon-2x&quot;&gt;&lt;/i&gt;
                &lt;span class=&quot;tabbar-label&quot;&gt;我&lt;/span&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>这里注意几个地方：</p>
<ul>
<li><p>views里添加 navbar-through类,这使得各个view中的页面默认有工具栏布局</p>
</li>
<li><p>toolbar里添加 toolbar-hidden类，这使得toolbar默认关闭，可以给欢迎页面或者登陆页面有全屏的效果。</p>
</li>
</ul>
<p>那么，如何使进入第二层以上的页面隐藏工具栏呢？</p>
<p>首先看看页面布局：</p>
<pre><code>&lt;div class=&quot;pages navbar-through&quot;&gt;
    &lt;div class=&quot;navbar&quot;&gt;
        &lt;div class=&quot;navbar-inner&quot;&gt;
            &lt;div class=&quot;center&quot;&gt;Framework7&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id=&quot;me&quot; data-page=&quot;Me&quot; class=&quot;page navbar-through no-swipeback&quot;&gt;
        &lt;div class=&quot;page-content contacts-content&quot;&gt;
            ...
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>page中添加no-toolbar类，这使得这个页面有无工具栏布局（底部没有留空），而这仅仅是对page布局有作用，而不会有文档中说的自动隐 藏toolbar效果，因为no-toolbar只会对跟该页面同view下的toolbar起作用，而我们的toolbar不是在view内，而是在各个view之外，所以要隐藏toolbar，还是要靠JS来实现。</p>
<p>因为本人是初学者，看不懂RequireJS ，所以JS部分是我自己写的。<br>而JS的重点就在于，如何监听当前页面是否在首层呢？很容易想到，要Page添加事件，检验一下当前页是否为第一层的页面。但是要监听什么事件呢？</p>
<p>如果是pageInit事件，那么在后退时会出现问题，因为F7为了呈现页面动画切换效果，在返回时会提前初始化前一个页面，比如，页面跳转顺序是A —&gt;B—&gt;C，现在要从C返回B，在返回前，view内会有BC两个页面以供切换，而切换到B的时候，F7会销毁C页面，加载A页面，这时会触发pageInit事件，如果用在pageInit触发时隐藏工具栏，那么当你从C切换到B时，工具栏就隐藏了，显然不符合我们要在A页面隐藏的要求。<br>而pageAfterBack事件是在返回动作完成后触发，这就会使得动画效果不连贯，不美观。</p>
<p>那么，应该用哪个事件呢？</p>
<p>我这里用的是pageBeforeAnimation，在页面加载完成后不触发，等要切换了动画要开始前才触发。这样，我们就能够在进行页面切换 动画的同时进行工具栏显示动画。</p>
<p>而另一个重点是，如何检测页面是否为第一层的页面？</p>
<p>大家都知道，页面事件会传入一个参数e，通过e.detail.page获得pageData，里面包括了name，url等。但是，这个e传的是触发事件的参数，比如从B切换到A，传入的是B页面的参数，所以用name、url等都不能检测出要切换到的页面是否为A页面。但是，当然这个是有解决的办法的。我们从文档中可以找到，PageData中的page.view可以获取当前view，而Views中的View.activePage属性却可以获取当前view的活动页面，也就是说，B切换到A，在动画是在A页面上进行的，活动页是A，所以，这样就能获取到我们要切换到的那个页面的数据了，再进行检验，就OK啦！</p>
<p>好啦，分析完，下面是JS代码</p>
<pre><code> //初始化后动画开始前检测当前视图的活动页，如果是第一层的4个页面，则显示工具栏
$$(document).on(&#39;pageBeforeAnimation&#39;, function (e) {
    var page = e.detail.page.view.activePage;
    if (page.name === &#39;Course&#39; || page.name == &#39;Book&#39; || page.name == &#39;Discover&#39; || page.name == &#39;Me&#39;) {
        myApp.showToolbar(&#39;.toolbar&#39;);
    }
    else {
        myApp.hideToolbar(&#39;.toolbar&#39;);
    }
});
</code></pre><p>好啦，这个问题就解决啦！希望大家多多分享你的经验哦！另外，有问题的话记得先看看文档，因为文档会解决很多问题的！</p>
]]></content>
      
        
        <tags>
            
            <tag> Framework7 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Jexus环境部署Ghost博客系统]]></title>
      <url>/install-ghost-blog-on-jexus-successfully.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>###建博感言<br>很久以前就想有自己的博客，但由于无暇顾及而荒废了。之前使用过WordPress，它的功能十分强大，安装之后就一直手痒弄着主题和插件。但是这实在太麻烦了，也不是我最终需要的，。我自认不是一个设计师，不能做出个漂亮的东西，但我喜欢什么样的博客我还是知道的。</p>
<p>###本文主题<br>Ghost博客系统由node.js写成，它的轻便以及高性能不言而喻，界面用bootstrap风格，原生多种客户端，默认使用Markdown编辑器，完全就是为书写而打造，实在是漂亮，很早之前就想使用，但由于没有自己的服务器，所以一直没用上，现在阿里云有学生优惠，买了配置很低的服务器，就打算使用Ghost来作为我的博客。</p>
<p>而我的服务器环境有点特殊。</p>
<p>我本身是个.NET开发者，但由于还是学生，囊中羞涩，又因为相对与Windows服务器，Linux在性能和安全性上确更胜一筹，而.NET的跨平台技术已经进行很长一段时间了，微软去年也宣布了.NET开源和在跨平台上努力着，所以我认为.NET跨平台将是一个行业的趋势，希望能学习在Linux服务器上运行我的.NET程序。</p>
<p>于是我用的服务器程序是Jexus，一个强大的.NET服务器。</p>
<p>可能使用Jexus的.NET极客们大多使用自己写的.NET博客系统（已经有大神写出一个开源系统）或者是WordPress，网上并没有关于在Jexus上部署Ghost的教程，但是可以发现网上的教程有一个共通点，就是都使用Web Server的反向代理，而不是直接运行在其之上（而是运行在node.js上的），正好Jexus上有强大的反向代理功能，正好这个功能没使用过，于是今天我就在Jexus上部署了Ghost博客程序。</p>
<p>###过程<br>node.js和Ghost的安装步骤在官网上都有，我们只需要安装ghost的部骤，不安装和配置服务器程序，因为我们已经安装好jexus了。其中要注意的是，如果直接下载node.js最新版本，就会下载版本号为4.1.1的node.js，而Ghost只能是0.10.<em> - 0.12.</em>,官方推荐使用0.10.40，所以记得下载特定版本。</p>
<p>###步骤</p>
<p> <strong>安装必要的Ubuntu软件包：</strong></p>
<pre><code>sudo apt-get update

sudo apt-get upgrade -y

sudo aptitude install -y build-essential zip vim wget
</code></pre><p><strong>获取node.js</strong></p>
<pre><code>sudo wget http://nodejs.org/dist/v0.10.40/node-v0.10.40.tar.gz

tar -zxf node-v0.10.40.tar.gz 

cd node-v0.10.40

$ ./configure 

$ make 

$ sudo make install 
</code></pre><p><strong>安装Ghost中文版</strong></p>
<pre><code>cd /var/www/myblog/

wget http://dl.ghostchina.com/Ghost-0.7.0-zh-full.zip

unzip -d ghost Ghost-0.7.0-zh-full.zip

cd ghost

sudo npm install --production

npm start
</code></pre><p>此时Ghost已安装完成，但是一旦使用<code>Ctrl+C</code>退出到控制台，Ghost进程就会关闭。为了使我们的程序一直保持在后台运行，我们需要使用进程保护程序<em>PM2</em>。</p>
<pre><code>//需要先进入上面Ghost的安装目录，执行：
  sudo npm install pm2 -g

//创建一个守护进程，其中“ghost”是对这个进程的命名，可自行修改
  NODE_ENV=production pm2 start index.js --name &quot;ghost&quot;

//让PM2知道在开机后自动运行我们的网站
  pm2 startup ubuntu
  pm2 save
</code></pre><p><strong>pm2相关命令:</strong></p>
<p><code>pm2 kill ghost</code>（清除所有ghost进程）</p>
<p><code>pm2 &lt;start|stop|restart&gt; ghost</code>（启动|停止|重启ghost进程）</p>
<p><code>pm2 startup &lt;centos|ubuntu|amazon&gt;</code> （让pm2能够在这3个系统上自动启动）</p>
<p>至此，pm2 已经可以守护 Ghost 博客永远在线。</p>
<p><strong>Jexus配置</strong></p>
<p>等Ghost安装之后，就到了Jexus出场了！我们在这里使用的是Jexus强大的的反向代理功能。将我们自己的域名绑定到Ghost在服务器上的本地IP，只需在Jexus新建一个配置文件，并加入一行：<code>reproxy=/  http://127.0.0.1:2368</code>即可，完整的配置是：</p>
<pre><code>port=80
root=/ /var/www/ghost/ghost #ghost所在目录
hosts=yangshunjie.com #你需要的域名
reproxy=/  http://127.0.0.1:236
</code></pre><p>最后记得在配置文件<code>config.js</code>里设置你的域名哦！</p>
<p>###总结</p>
<p>这个部署过程让我学会node.js的部署，以及Jexus反向代理的一个用处，就是绑定域名到其他web Server的程序上，这样以后就可以在同一服务器上运行多种语言的程序了（我的服务器目前是.NET+PHP+Node.js）</p>
<blockquote>
<p><a href="http://www.applecho.com/installing-ghost-ubuntu/" target="_blank" rel="external">Ghost博客平台：在Ubuntu上安装Ghost</a></p>
<p><a href="http://www.applecho.com/installing-ghost-pm2/" target="_blank" rel="external">Ghost博客平台：安装pm2</a></p>
<p><a href="http://www.cnblogs.com/shanyou/archive/2013/05/04/3059950.html" target="_blank" rel="external">Jexus 负载均衡</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 环境部署 </tag>
            
            <tag> Jexus </tag>
            
            <tag> Blog </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[分类]]></title>
      <url>/categories.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[留言板]]></title>
      <url>/contact.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>有什么想说，就到这里留言吧！我会很快给你答复！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[朋友们]]></title>
      <url>/friends.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[相册]]></title>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>/about.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul>
<li>杨舜杰</li>
<li>男</li>
<li>2016年于广东海洋大学计算机科学与技术专业毕业</li>
<li>联系方式：<a href="mailto:shunjiey@hotmail.com" target="_blank" rel="external">shunjiey@hotmail.com</a></li>
<li>Github: <a href="http://github.com/elderjames" target="_blank" rel="external">github.com/elderjames</a></li>
</ul>
<h3 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h3><ul>
<li>喜欢接触新鲜事物，尤其是最新科技</li>
<li>时刻关注国内外科技动态，尤爱数码产品</li>
<li>《哈利波特》是童年，周杰伦是青春，大学后迷上美剧</li>
<li>以前喜欢动手做东西，后来喜欢动手写程序</li>
</ul>
<h3 id="大学经历"><a href="#大学经历" class="headerlink" title="大学经历"></a>大学经历</h3><ul>
<li>大一爱上了轮滑，在轮协认识了很多朋友</li>
<li>曾任校学生会网络信息部委员、部长</li>
<li>开发校园助手爱海大，但弄了很久，但一定要弄好</li>
</ul>
<h3 id="理想"><a href="#理想" class="headerlink" title="理想"></a>理想</h3><ul>
<li>据说每个程序员都有一个要改变世界的理想</li>
</ul>
<h3 id="目前"><a href="#目前" class="headerlink" title="目前"></a>目前</h3><ul>
<li>就职于<a href="http://www.100cb.cn/" target="_blank" rel="external">广州百财帮网络金融信息服务有限公司</a> 任.NET开发工程师</li>
<li>业余喜欢学习前端、.NET Core、docker、Cordova 等技术</li>
<li>想养只猫了</li>
</ul>
<input type="text">]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[标签]]></title>
      <url>/tags.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[时间轴]]></title>
      <url>/timeline.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[欢迎使用 Ghost 博客系统]]></title>
      <url>/welcome-to-ghost-2.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Yeah，博客上线了！这篇文章的目的是向你介绍 Ghost 编辑器并帮你快速上手。通过 <code>&lt;your blog URL&gt;/ghost/</code> 链接就可以登录系统后台管理你的博客内容了。当你进入后台，你就能看到左侧文章列表处列出的这篇文章，右侧就是这篇文章的预览效果。点击预览栏右上角的铅笔图标就能进入内容编辑页面。 </p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>Ghost 使用 Markdown 语法书写内容。简单来说，Markdown 就是一种简化的书写格式！</p>
<p>用 Markdown 语法写作是很容易的。在编辑界面的左侧就是你写作的地方。在你认为需要的时候，可以使用以下这些语法来格式化你的内容。例如下面这个无序列表：</p>
<ul>
<li>Item number one</li>
<li>Item number two<ul>
<li>A nested item</li>
</ul>
</li>
<li>A final item</li>
</ul>
<p>还可以是有序列表：</p>
<ol>
<li>Remember to buy some milk</li>
<li>Drink the milk</li>
<li>Tweet that I remembered to buy the milk, and drank it</li>
</ol>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>如果要链接其它页面，可以直接把页面的 URL 粘贴过来，例如 <a href="http://www.ghostchina.com" target="_blank" rel="external">http://www.ghostchina.com</a> - 会被自动识别为链接。但是，如果你想自定义链接文本，可以像这样： <a href="http://www.ghostchina.com" target="_blank" rel="external">Ghost 中文网</a>。很简单吧！</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>插入图片也没问题！前提是你事先知道图片的 URL，然后像下面这样：</p>
<p><img src="http://static.ghostchina.com/image/3/fe/34a9831916be9db1381ecb320491e.png" alt="The Ghost Logo"></p>
<p>如果图片在本地的硬盘里怎么办？也很简单！像下面这样书写就能为图片预留一个位置，然后你可以继续写作，回头再通过拖拽的方式把图片上传到服务器上。</p>
<p>![一张图片]</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>有些时候我们需要引用别人说的话，可以这样：</p>
<blockquote>
<p>Wisdomous - it’s definitely a word.</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>或许你是个码农，需要贴一些代码到文章里，可以通过两个引号（Tab 键上面的那个键）加入行内代码 <code>&lt;code&gt;</code>。如果需要加入大段的代码，可以在代码前加 4 个空格缩进，这就是 Markdown 的语法。</p>
<pre><code>.awesome-thing {
    display: block;
    width: 100%;
}
</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在任一新行输入 3 个或更多的短横线（减号）就是一条分隔线了。</p>
<hr>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>Markdown 还有一个特别用法，就是在你需要的时候可以直接书写 HTML 代码。</p>
<input type="text" placeholder="这是个输入框！">

<p>只要掌握了上面的这些介绍，你就已经入门了！继续写作吧！</p>
]]></content>
    </entry>
    
  
</search>
